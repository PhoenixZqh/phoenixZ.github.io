---
layout:     post
title:      ROS 总结
subtitle:   
date:       2025-11-26
author:     phoenixZ
header-img: /img/oip3.jpg
catalog: true
tags:
    - boss
    - ROS
---
# ROS1

## Topic / Service / Action 区别与场景：| 类型    | 特点与典型场景                                                      |

| ------- | ------------------------------------------------------------------- |
| Topic   | 单向、异步、发布-订阅模式；适合传感器高频数据（激光、图像、里程计） |
| Service | 双向、同步、请求-应答模式；适合短时、确定性的操作（拍照、查询地图） |
| Action  | 双向、异步、可取消并可反馈进度；适合长时间任务（导航、机械臂抓取）  |

## spin 和 spinonce的区别

- ros::spin(),  阻塞式循环，不断地检查是否有新的消息到达，直到节点关闭。,适用于订阅节点，作为程序的主循环。
- ros::spinOnce(),  非阻塞式，只检查和处理一次当前队列中的所有等待消息和事件。,适用于主程序有其他实时任务，需要手动控制消息处理频率的节点。

## 为什么订阅者发布者都需要设置缓存队列？

1. 发布者 (Publisher) 队列：

   作用： 存储待发送的消息。

   场景： 如果发布速度大于网络传输或订阅者处理速度，多余的消息会先在队列中等待。当队列满时，默认策略是丢弃最老的消息，以保证系统对最新数据的响应能力。

   2. 订阅者 (Subscriber) 队列：

   作用： 存储已接收但尚未被回调函数处理的消息。

   场景： 如果消息接收速度大于回调函数处理速度（例如，回调函数处理很耗时），消息会在队列中排队。当队列满时，同样会丢弃最老的消息，防止内存爆炸和数据陈旧。

## 回调函数中为什么不能阻塞？ 如何解决？

⚠️ 为什么不能阻塞？

1. 回调函数是 ROS 接收消息或事件并进行处理的地方。如果回调函数发生阻塞会导致：
2. 消息积压/丢失： ROS 的消息处理机制（如 spin()）会被阻塞，无法处理新的传入消息，导致订阅者队列填满，消息被丢弃。
3. 死锁： 如果在阻塞的回调函数中又试图获取同一资源的锁，或调用另一个同步等待的 Service/Action，可能造成系统级别的死锁。
4. 系统实时性下降： 严重影响整个系统的响应速度和实时性能。

✅ 如何解决？

5. 主要通过将耗时任务异步化来解决：

- 多线程处理 (Multi-threading)：
- 使用 ros::AsyncSpinner 或自定义线程池 (ros::CallbackQueue)。
- 耗时操作移出回调函数，放到单独的线程中执行。回调函数只负责快速地将数据交给另一个线程（例如，通过线程安全队列）。

## ROS Master的作用

ROS Master 是 ROS 图 (ROS Graph) 中的命名服务中心。它的主要作用是：

1. 命名和注册服务 (Naming and Registration)： 节点启动时，向 Master 注册自己的名称、发布的 Topic、提供的 Service 等信息。
2. 查找服务 (Lookup Service)： 节点间通信时，Master 充当“黄页”的角色。例如，订阅者会向 Master 查询某个 Topic 的发布者在哪里。
3. 连接握手 (Handshake)： Master 促成发布者和订阅者之间的直接连接（通常是 TCP/IP 或 UDP），一旦连接建立，Master 就会退出通信路径。

总结： Master 负责节点间的信息交流和连接建立，但不参与实际的数据传输。

## roscore, rosrun, roslaunch 的区别？

| **命令**          | **作用**                                                            | **场景**                                                      |
| ----------------------- | ------------------------------------------------------------------------- | ------------------------------------------------------------------- |
| **`roscore`**   | 启动**ROS Master** 、参数服务器和日志节点。                         | 运行任何 ROS 节点**之前**必须首先启动它。                     |
| **`rosrun`**    | **运行单个 ROS 节点** 。                                            | 调试单个节点、简单测试。`rosrun <package_name> <executable_name>` |
| **`roslaunch`** | **运行一个或多个节点** ，可配置参数、重映射、启动多个机器上的节点。 | 部署整个机器人系统、启动复杂配置。使用 XML 格式的 `.launch`文件。 |

## 参数服务器的特点？

参数服务器（Parameter Server）是 ROS Master 的一部分，用于存储节点间共享的配置数据。

* **集中存储：** 参数集中存储在 ROS Master 上，所有节点都可访问。
* **数据类型：** 支持字符串、数字、布尔值、列表和字典等基本类型。
* **持久性：** 只要 Master 运行，参数就存在。节点关闭不会清除参数。
* **不实时：** **不适合**存储高频率变化的数据（应使用 Topic），只适用于**静态或低频变化**的配置。

## 为什么ROS1不实时？

   ROS1 默认设计为非实时操作系统，主要原因在于其底层机制：

1. **基于标准 Linux/TCP：** 运行在标准 Linux 内核上，这是一个**通用**操作系统，其任务调度不提供硬实时保证。
2. **非实时通信协议：** 默认 Topic 使用  **TCP/IP** ，TCP 保证数据的 **可靠性** （不丢包），但通过重传和缓冲实现了可靠性，这 **引入了不确定的时间延迟** 。
3. **回调机制：** 消息处理在单个线程中（默认），如果回调函数处理不当或消息堆积，会造成不可预测的延迟。

**解决方案：**

* 使用 **RT-Linux** 等实时内核补丁。
* 迁移到  **ROS 2.0** ，它使用 **DDS** 作为底层通信，DDS 提供了 **QoS (Quality of Service)** 设置，允许用户配置实时性保证。

## 如何通过yaml读取参数

参数通常通过 Launch 文件加载 YAML 文件内容到参数服务器，再由节点读取。

{% highlight xml %}
    robot_name: "my_rover"
    speed_limit: 1.5
    sensors:
    lidar_topic: "/scan"
    camera_frame: "camera_link"
{% endhighlight xml %}

{% highlight xml %}
    `<launch>`
    `<rosparam command="load" file="$(find my_package)/config/config.yaml" ns="my_node/config" />`

    `<node name="my_node" pkg="my_package" type="my_node_executable" output="screen" />`
    `</launch>`
{% endhighlight xml %}

{% highlight cpp %}
    void read_parameters() {
        std::string name;
        double speed;

    // 读取简单参数
        if (ros::param::get("/my_node/config/robot_name", name)) {
            ROS_INFO("Robot name loaded: %s", name.c_str());
        } else {
            ROS_ERROR("Failed to get robot_name parameter.");
        }

    // 读取嵌套参数
        if (ros::param::get("/my_node/config/sensors/speed_limit", speed)) {
            ROS_INFO("Speed limit loaded: %.2f", speed);
        }
    }
{% endhighlight cpp %}

## 句柄的作用

1. 建立与 ROS Master 的连接
   第一次创建 NodeHandle 时，roscpp 自动向 Master 注册当前节点、注册 topic/service 等。
2. 管理所有通信对象的生命周期
   通过这个句柄创建的 Publisher、Subscriber、ServiceServer、ServiceClient、Timer 等，只要句柄不析构，这些对象就一直有效。
3. 自动处理命名空间和名称重映射（remap）
   不同句柄创建的 topic 名字会自动加上前缀

## 代码

{% highlight cpp %}
    #include <ros/ros.h>
    #include <std_msgs/String.h>
    #include <rospy_tutorials/AddTwoInts.h>

    class ExampleNode
    {
    public:
        ExampleNode(ros::NodeHandle& nh)
        {
            // Publisher
            pub_ = nh.advertise[std_msgs::String](std_msgs::String)("/result", 10);

    // Subscriber
            sub_ = nh.subscribe("/chatter", 10, &ExampleNode::chatterCallback, this);

    // Service Client
            client_ = nh.serviceClient[rospy_tutorials::AddTwoInts](rospy_tutorials::AddTwoInts)("/add_two_ints");

    // Service Server
            server_ = nh.advertiseService("/add_two_ints", &ExampleNode::addCallback, this);

    ROS_INFO("ExampleNode (ROS1) initialized.");
        }

    private:
        ros::Publisher pub_;
        ros::Subscriber sub_;
        ros::ServiceClient client_;
        ros::ServiceServer server_;

    // Subscriber callback
        void chatterCallback(const std_msgs::String::ConstPtr& msg)
        {
            ROS_INFO("Received: %s", msg->data.c_str());

    // 调用服务
            rospy_tutorials::AddTwoInts srv;
            srv.request.a = 3;
            srv.request.b = 5;

    if (client_.call(srv)) {
                ROS_INFO("Service call success: 3 + 5 = %ld", (long)srv.response.sum);

    std_msgs::String out_msg;
                out_msg.data = "Received: " + msg->data +
                            ", Service result = " + std::to_string(srv.response.sum);
                pub_.publish(out_msg);
            } else {
                ROS_WARN("Service call failed.");
            }
        }

    // Service Server callback
        bool addCallback(rospy_tutorials::AddTwoInts::Request &req,
                        rospy_tutorials::AddTwoInts::Response &res)
        {
            res.sum = req.a + req.b;
            ROS_INFO("Service Server: %ld + %ld = %ld", (long)req.a, (long)req.b, (long)res.sum);
            return true;
        }
    };

    int main(int argc, char** argv)
    {
        ros::init(argc, argv, "example_node_ros1");
        ros::NodeHandle nh;

    ExampleNode node(nh);

    ros::spin();
        return 0;
    }

{% endhighlight cpp %}

# ROS2

## ROS2 相对与ROS1的改进

| **特性**     | **ROS1 (Robot Operating System 1)** | **ROS2 (Robot Operating System 2)**                                                          |
| ------------------ | ----------------------------------------- | -------------------------------------------------------------------------------------------------- |
| **通信层**   | 自定义 TCP/UDP (TCPROS/UDPROS)            | **DDS (Data Distribution Service)**标准，提供实时、可靠通信。                                      |
| **实时性**   | 缺乏原生支持，非硬实时。                  | 通过 DDS 和优化的 Executor，**支持软实时** 。                                                |
| **多机器人** | 部署复杂，需要自定义网络配置。            | **原生支持**多机器人/分布式系统，网络发现和命名空间管理更健壮。                              |
| **平台支持** | 主要支持 Linux。                          | **跨平台** ：Linux (Ubuntu)、Windows、macOS、RTOS (如QNX)。                                  |
| **生命周期** | 节点启动后即运行，缺少状态管理。          | **支持生命周期管理** ，节点可以有明确的状态（如 `Unconfigured`,`Inactive`,`Active`）。 |
| **安全性**   | 默认缺乏安全机制。                        | **原生支持安全** ：基于 DDS-Security (SROS2)，提供加密和访问控制。                           |
| **语言支持** | 主要是 Python 2/3 和 C++。                | **标准化 API** ，支持 C++, Python 3，并易于扩展到其他语言。                                  |
| **构建系统** | Catkin (CMake 扩展)。                     | **Ament**(支持多种构建工具，如 CMake, Python setuptools)。                                   |

## ROS2核心组件的关系与作用


| **组件**                            | **作用**                                                                                            | **与其他组件的关系**                                                               |
| ----------------------------------------- | --------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- |
| **节点 (Node)**                     | 机器人系统中的基本执行单元（如一个传感器驱动、一个导航算法）。                                            | **发布/订阅** 、 **服务** 、**动作**是节点之间通信的机制。             |
| **话题 (Topic) & 发布者/订阅者**    | **异步** 、**点对多点**的消息传递机制。发布者发送消息，订阅者接收。                           | 最基本的通信方式，用于连续的数据流（如激光雷达、里程计）。                               |
| **服务 (Service) & 客户端/服务端**  | **同步** 、**请求-响应**机制。客户端发送请求，等待服务端返回结果。                            | 用于一次性的操作和配置（如设置参数、触发一个动作）。                                     |
| **动作 (Action) & 客户端/服务端**   | **异步** 、**长时任务**机制。客户端发送目标，服务端执行任务，并提供 **周期性的反馈** 。 | 用于需要长时间执行且需要中间状态的任务（如移动到目标点）。                               |
| **参数 (Parameter)**                | 节点的动态配置值。                                                                                        | 可在运行时通过 ROS 服务机制进行**读取和设置** 。                                   |
| **Executor**                        | 负责**事件处理和回调** 。它从 DDS 监听队列中获取事件（如新消息、服务请求）并调用相应的回调函数。    | 是**节点运行的机制** 。开发者通常使用默认的 Executor，但可以自定义以优化实时性能。 |
| **DDS (Data Distribution Service)** | **底层通信中间件** 。负责所有节点间的发现、数据传输和 QoS 策略实施。                                | **ROS2 的通信骨干** ，所有 ROS 消息都通过 DDS 传输。                               |

## 什么是DDS？

**DDS** 是 **Data Distribution Service (数据分发服务)** 的缩写，它是一种 **以数据为中心 (Data-Centric)** 、 **实时** 、**发布/订阅**的消息中间件标准。

### 核心特性和工作原理

1. 以数据为中心 (Data-Centric)

DDS 的核心概念是 **全局数据空间 (Global Data Space)** 。

* **数据对象 (Topic/Domain):** 节点不是直接向特定的节点发送消息，而是将数据写入到这个全局数据空间中特定的“主题”或“域”下。
* **通信解耦:** 发布者和订阅者之间高度解耦。它们不需要知道彼此是否存在、位置或数量。它们只关心数据本身。

2. 发布/订阅 模型 (Publish/Subscribe)

与 ROS 的话题机制类似，DDS 使用发布/订阅模型：

* **发布者 (DataWriter):** 负责将数据发布到一个或多个主题。
* **订阅者 (DataReader):** 负责订阅一个或多个主题，接收感兴趣的数据。

3. 强大的 QoS (Quality of Service)

这是 DDS 最强大的特性之一，也是 ROS2 性能和可靠性的基础。

* **动态策略定制:** DDS 允许开发者为每个数据流设置细粒度的通信策略，如可靠性 (`Reliable` vs `Best-Effort`)、历史记录 (`Keep-Last` vs `Keep-All`)、生命周期 (`Durability`) 等。
* **保证通信需求:** 通过 QoS 策略，可以保证关键数据（如控制指令）的可靠性，同时允许非关键数据（如高频传感器数据）为了速度而牺牲少量可靠性。

4. 实时性和发现机制

* **实时性能:** DDS 协议设计用于提供可预测的、高性能的通信，支持软实时应用。
* **自动发现:** 当一个 DDS 应用程序（如 ROS2 节点）启动时，它会自动在网络上发现其他正在运行的 DDS 实体，无需人工配置 IP 地址或端口。

## Qos是什么？Reliability、Durability、History的含义和场景？

QoS 是一组策略的集合，用于定义通信的**可靠性、及时性和资源消耗**等属性。ROS2 中的 QoS 策略直接映射到底层的 DDS 机制，允许开发者根据数据流的特性（例如，传感器数据 vs. 关键控制命令）来定制通信行为。


| **QoS 策略**             | **含义 (What)**                              | **选项 (Values)**                                                                                                                      | **典型场景 (When)**                                                                                                                                              |
| ------------------------------ | -------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Reliability (可靠性)** | 是否保证消息一定能到达接收端。                     | **`BEST_EFFORT`(尽力而为)** ：发送但不保证到达，速度更快。 **`RELIABLE`(可靠)** ：发送方会重试直到接收方确认，保证消息到达。 | **`BEST_EFFORT`** : 连续、高频率的传感器数据（如点云、图像），允许少量丢包以提高速度。 **`RELIABLE`** : 关键控制命令、导航目标、服务请求/响应。        |
| **Durability (持久性)**  | 订阅者加入时，是否接收其离线时发布者已发送的消息。 | **`VOLATILE`(易失性)** ：只接收新消息。 **`TRANSIENT_LOCAL`(临时本地)** ：发布者会保留最新消息，供新的订阅者接收。           | **`VOLATILE`** : 实时、连续的数据流。 **`TRANSIENT_LOCAL`** : 参数服务、地图数据或机器人状态，确保新加入的节点能立即获取当前状态。                     |
| **History (历史记录)**   | 发布者或接收者如何管理消息队列。                   | **`KEEP_LAST`** : 只保留最近的**$N$**条消息。 **`KEEP_ALL`** : 尽可能保留所有消息。                                        | **`KEEP_LAST`** : 常用，通过设置**$N=1$**来获取最新状态；设置**$N>1$**来平滑数据。 **`KEEP_ALL`** : 调试或需要保证顺序的非实时场景（少用）。 |

## ROS2的生命周期管理是什么？


ROS2 引入了 **生命周期管理 (Lifecycle Management)** ，它允许节点在运行时拥有明确的、可控的状态。这对于开发健壮、可预测和符合功能安全标准的系统至关重要。

### **核心概念：生命周期节点 (Lifecycle Node)**

一个生命周期节点不再是启动即运行，而是遵循一个定义好的 **状态机** 。

### **关键状态**

生命周期节点主要有以下状态：

* **`UNCONFIGURED` (未配置)** : 节点刚启动，尚未进行任何配置。
* **`INACTIVE` (非激活)** : 节点已完成配置（如加载参数），但**未开始执行**实际任务（例如：未连接传感器、未发布话题）。
* **`ACTIVE` (激活)** : 节点**正在执行**其主要任务（例如：开始读取传感器、发布里程计、运行控制算法）。
* **`FINALIZED` (终结)** : 节点即将关闭，所有资源已被释放。

### **关键转换 (Transitions)**

开发者通过显式调用以下转换，将节点从一个状态迁移到另一个状态：

| **转换**           | **描述**                       | **目的**                                                                                |
| ------------------------ | ------------------------------------ | --------------------------------------------------------------------------------------------- |
| **`configure`**  | 从 `UNCONFIGURED`到 `INACTIVE`。 | 加载并校验配置（如 YAML 文件），但不分配昂贵的资源。                                          |
| **`activate`**   | 从 `INACTIVE`到 `ACTIVE`。       | **分配**和**启用**所有必要的资源（如打开设备、建立 DDS 连接），开始执行核心功能。 |
| **`deactivate`** | 从 `ACTIVE`到 `INACTIVE`。       | **停止**核心功能和数据流，但**不释放**配置资源，为快速重启做准备。                |
| **`cleanup`**    | 从 `INACTIVE`到 `UNCONFIGURED`。 | 释放所有配置资源，回到初始状态。                                                              |

## 代码

{% highlight cpp %}

    #include`<memory>`
    #include `<string>`

    #include "rclcpp/rclcpp.hpp"
    #include "std_msgs/msg/string.hpp"
    #include "example_interfaces/srv/add_two_ints.hpp"

    class ExampleNode : public rclcpp::Node, public std::enable_shared_from_this`<ExampleNode>`
    {
    public:
        ExampleNode()
        : Node("example_node_ros2")
        {
            // Publisher
            pub_ = this->create_publisher[std_msgs::msg::String](std_msgs::msg::String)("/result", 10);

    // Subscriber
            sub_ = this->create_subscription[std_msgs::msg::String](std_msgs::msg::String)(
                "/chatter",
                10,
                std::bind(&ExampleNode::chatterCallback, this, std::placeholders::_1)
            );

    // Service Client
            client_ = this->create_client[example_interfaces::srv::AddTwoInts](example_interfaces::srv::AddTwoInts)("/add_two_ints");

    // Service Server
            server_ = this->create_service[example_interfaces::srv::AddTwoInts](example_interfaces::srv::AddTwoInts)(
                "/add_two_ints",
                std::bind(&ExampleNode::addCallback, this, std::placeholders::_1, std::placeholders::_2)
            );

    RCLCPP_INFO(this->get_logger(), "ExampleNode (ROS2) initialized.");
        }

    private:
        rclcpp::Publisher[std_msgs::msg::String](std_msgs::msg::String)::SharedPtr pub_;
        rclcpp::Subscription[std_msgs::msg::String](std_msgs::msg::String)::SharedPtr sub_;
        rclcpp::Client[example_interfaces::srv::AddTwoInts](example_interfaces::srv::AddTwoInts)::SharedPtr client_;
        rclcpp::Service[example_interfaces::srv::AddTwoInts](example_interfaces::srv::AddTwoInts)::SharedPtr server_;

    // Subscriber callback
        void chatterCallback(const std_msgs::msg::String::SharedPtr msg)
        {
            RCLCPP_INFO(this->get_logger(), "Received: %s", msg->data.c_str());

    // 等服务可用
            if (!client_->wait_for_service(std::chrono::seconds(1))) {
                RCLCPP_WARN(this->get_logger(), "Service not available.");
                return;
            }

    auto request = std::make_shared[example_interfaces::srv::AddTwoInts::Request](example_interfaces::srv::AddTwoInts::Request)();
            request->a = 3;
            request->b = 5;

    auto result_future = client_->async_send_request(request);

    // 同步等待结果
            if (rclcpp::spin_until_future_complete(shared_from_this(), result_future) ==
                rclcpp::FutureReturnCode::SUCCESS)
            {
                auto result = result_future.get();
                long sum = result->sum;

    RCLCPP_INFO(this->get_logger(), "Service result: %ld", sum);

    std_msgs::msg::String out_msg;
                out_msg.data = "Received: " + msg->data +
                            ", Service result = " + std::to_string(sum);
                pub_->publish(out_msg);
            } else {
                RCLCPP_WARN(this->get_logger(), "Service call failed.");
            }
        }

    // Service Server callback
        void addCallback(
            const std::shared_ptr[example_interfaces::srv::AddTwoInts::Request](example_interfaces::srv::AddTwoInts::Request) request,
            std::shared_ptr[example_interfaces::srv::AddTwoInts::Response](example_interfaces::srv::AddTwoInts::Response) response)
        {
            response->sum = request->a + request->b;
            RCLCPP_INFO(this->get_logger(), "Service Server: %ld + %ld = %ld",
                        request->a, request->b, response->sum);
        }
    };

    int main(int argc, char **argv)
    {
        rclcpp::init(argc, argv);
        rclcpp::spin(std::make_shared`<ExampleNode>`());
        rclcpp::shutdown();
        return 0;
    }

{% endhighlight cpp %}
