---
layout:     post

title:      复盘

subtitle:   

date:       2025-12-18

author:     phoenixZ

header-img: /img/oip3.jpg

catalog: true

tags:
    - boss
---
# 中科华创

## 一面

### 从NX迁移到3588遇到了什么困难？ 性能可以保证吗？

1. 算子不支持
2. 3588s温度上来后掉频影响前后处理时间
3. 性能可以保证， 利用线程池

| 尺寸      | 推理速度 | 线程   |
| --------- | -------- | ------ |
| 640x640   | 39       | 单     |
| 1280x1280 | 10       | 单     |
| 640x640   | 120      | 三线程 |

### 多车协同路径规划遇到了什么困难？

回答：

1. 在避静态障碍物的时候将车的四个角点位置加入约束， 车的动力学特性考虑进来
2. 动态避障的时候利用轨迹， 采用时间窗口判断位置和速度上是否会发生碰撞

### 遥控导航避障怎么做的？ 成功率怎么样？

回答：

1. 离线创建4万多条轨迹，创建体素与轨迹的关联表
2. 在线主要是局部感知过滤掉有障碍物的轨迹； 视野外的用目标朝向一致性打分
3. 最后从离线轨迹库中找到到达目的地成功概率最大的轨迹
4. 成功概率没有测过，最差的情况是找不到轨迹， 触发停止逻辑

## 二面

### 防丢失具体怎么做的？蓝色卡尔曼滤波的框是什么意思？

### 从轨迹库中挑选轨迹会不会很耗时？

# 涂鸦智能

## 一面

1. 智能指针的底层实现？ 作用是什么？

   - 引用计数，跟踪当前有多少个shared_ptr实例正在共享和拥有这个对象
   - 每当有一个新的实例指向这个对象的时候引用计数+1
   - 每当一个shared_ptr被销毁（比如离开了作用阈）或重置时，引用计数-1
   - 引用计数清零的时候，调用该对象的析构函数自动释放被管理对象占用的内存
2. 标定怎么做的？

   - 随机给个外参， 目标是优化投影点与图像点之间距离误差的平方和
3. 有没有做过ROS多线程开发？

   - 基于spinonce和while循环做多线程
4. 算子开发有做过吗？

## 二面

1. 640x640x15帧 算力需求
   1tops以内可以做到
2. 家庭式目标跟随你会怎么做
   回答： 根据像素偏移来做跟踪， 其实应该更深层次一点， 用户上传图像或基于视频选择目标，结合reid、多标签分类技术实现目标锁定，然后测距， 对目标进行持续的跟随。 可以添加可见性与安全性约束、防止目标丢失。

# 乐聚机器人

1. 说说topic、 service、 action的区别
   Action 机制结合了 Topics 和 Services 的优点，但增加了关键的 反馈 和 可中断 功能，是双向异步的。
2. 如何定位节点之间是否通信正常？ 定位问题出在哪里？

   - 检查rosmaster是否正常工作，rostopic list & info 查看节点是否起来了
   - 单独话题查看，rostopic hz & echo
   - rqt_graph 查看
   - 看能不能ping通
   - 看消息类型是否一致/节点名是否有冲突
   - 写log查看
3. cpp 程序崩溃的原因有那些？ 重复释放会立马崩溃吗？

   - 数组访问越界
   - 访问控制真
   - 未捕获的异常
   - 除0
   - 重复释放统一快内存： 不一定会立马触发崩溃
4. 说一说ROS2与ROS1的区别

# 浙江交投

1. 解锁是哪一号协议

   答： 76号消息
2. 光流的作用？ 能单独使用吗

   答: 光流一般是用来作水平速度计算的。 需要和TOF结合使用，在室内可作定位

# 波普环境

1. A*原理
2. 协同搜索原理

# 鸿日达

1. new 和 malloc的区别？

   | 特性       | malloc / free                   | new / delete                       |
   | ---------- | ------------------------------- | ---------------------------------- |
   | 本质       | 标准库函数 (stdlib.h)           | C++ 运算符 (关键字)                |
   | 构造/析构  | 只分配内存，不调用构造/析构函数 | 分配内存后自动调用构造/析构函数    |
   | 返回类型   | 返回 void*，需要强转            | 返回对象类型的指针，具有类型安全性 |
   | 失败行为   | 返回 NULL                       | 抛出 std::bad_alloc 异常           |
   | 内存重分配 | 可以使用 realloc                | 不支持，需重新申请并拷贝           |
2. vector底层原理？
   vector 本质上是一个动态增长的数组。

   - 核心成员：通常由三个指针实现：_Myfirst (指向起始位置)、_Mylast (指向当前元素末尾)、_Myend (指向可用内存末尾)。
   - 扩容机制：当 size == capacity 时，它会重新申请一块更大的内存（通常是原容量的 1.5 倍或 2 倍），将旧元素移动/拷贝到新内存，并释放旧内存。
   - 复杂度：随机访问为 $O(1)$，尾部插入在不扩容时为 $O(1)$（摊还复杂度），中间插入为 $O(n)$。
3. 构造函数和析构函数能不能是虚函数？

   构造函数：不能。

   - 虚函数表指针 (vptr) 是在构造函数执行期间初始化的。在对象还没构造好之前，虚函数表尚不存在，无法通过虚表进行多态调用。

   析构函数：可以，且通常必须。

   - 当你使用基类指针指向子类对象并执行 delete 时，如果析构函数不是虚函数，编译器只会调用基类的析构函数，导致子类特有的资源（内存、文件句柄）无法释放，造成内存泄漏。
4. shared_ptr存在的问题以及解决办法？

   - 问题：如果两个对象互相持有对方的 shared_ptr，它们的引用计数永远不会降到 0，导致内存无法回收。
   - 解决办法：引入 std::weak_ptr。

   weak_ptr 是一种"观察者"指针，它指向对象但不增加引用计数。

   只要将其中一个对象的持有方式改为 weak_ptr，就能打破循环。
5. 浅拷贝与深拷贝的区别？

   - 浅拷贝 (Shallow Copy)：仅拷贝指针的地址，不拷贝指针指向的内容。

     风险：两个对象指向同一块内存，其中一个销毁后，另一个变为野指针；或者两次释放同一块内存导致崩溃。
   - 深拷贝 (Deep Copy)：为新对象重新申请内存，并完整拷贝源对象指向的所有内容。
6. 设计模式有了解吗？

   - 单例模式 (Singleton)：确保某个类（如全局配置、硬件驱动接口）只有一个实例。
   - 观察者模式 (Observer)：常用于传感器数据分发，当数据更新时通知所有订阅者。
   - 工厂模式 (Factory)：根据不同参数创建不同类型的传感器处理对象。
   - 状态模式 (State)：在机器人控制逻辑中管理不同的运行状态（如待机、运行、故障）。

# 极目机器人

1. 起飞点不一样对测距的影响
2. A* 与 B样条轨迹优化的算法原理

# 青鸟智航

1. 详细讲一下EKF？ 协方差的作用？

   **答：**

   - EKF 通过一阶泰勒展开将非线性系统局部线性化，从而套用卡尔曼滤波的公式；结合模型预测值和带噪声的测量值获得当前时刻的最优估计
   - 协方差矩阵 P 是连接过程噪声 Q 和测量噪声 R 的桥梁，动态反映了系统对预测和观测模型的信任程度
2. 飞控接入陀螺仪、加速度计后如何得到位姿的？

   - 陀螺仪：对角速度进行积分得到角度； 缺点是时间久了角度会由于积分误差完全错误
   - 加速度计: 在静止或者匀速状态下没，利用重力向量g计算pitch 和 roll；缺点是动态震荡大，且无法感知yaw
   - 融合：结合两者，用加速度计修复陀螺仪的累计漂移
3. 进程间通信方式？

   - 管道
   - 消息队列
   - 共享内存
   - 信号量
   - 套接字
4. 线程间通信方式？

   - 共享全局变量
   - 条件变量
   - 信号量
   - 套接字
5. 互斥锁与自旋锁的区别？

   - 互斥锁：如果锁被占用，线程会进入睡眠，交出CPU给其他线程。等锁释放后被唤醒； 用于等待时间长，不希望浪费CPU的场景；
   - 自旋锁：如果锁被占用，线程会循环忙等(cpu不停空转)，直到拿到锁；用于等待时间短的场景，因为线程切换的开销比忙等还要大；
6. 话题延迟的处理方式？

   - 回答的是利用时间戳来同步信息
7. function 的用处？

   是一个通用、多态的函数包装器，用于统一处理各种类型的可调用对象。

   常见的可调用对象包括（顺序与 `2025-12-07-cpp总结.md` 中示例一致）：

   - 普通函数
   - 仿函数
   - lambda 表达式
   - 类成员函数
   - 类静态成员函数
8. 类模板的作用？

- 代码复用，同一份代码支持多种数据类型
- 类型安全，编译器在实例化时进行类型检查，比 void* 或宏更加安全
- 性能优秀，实例化在编译期间完成，生成的代码与手写特定版本性能一致

9. ROS1 存在的缺点？

- 强依赖 master
- 通信机制非实时，延迟不可预测
- 平台支持有限

10. B 样条轨迹优化的数学原理？

- B 样条的核心是将轨迹参数化为 B 样条曲线，基本数学表示是将曲线描述为一系列控制点和基函数的加权和，这种表示允许曲线在参数空间中灵活变化，通过优化控制点来最小化目标函数，同时满足平滑性、避障和动力学约束
- 一个 P 次 B 样条曲线定义为控制点序列 Pi(i=0～N)，节点向量 U={u0,u1，...，um} 的加权和

11. 如何将类的成员函数作为参数传递给回调函数？

- 使用function + bind 绑定器
- 使用lambda表达式直接捕获this指针

  {% highlight cpp %}
  //! 方式1： 使用function + bind
  class Processor {
  public:
  void process(int value) {
  std::cout << "Processor::process called with " << value << std::endl;
  }

  // 回调类型：接受一个 void(int) 的函数对象
  void registerCallback(std::function<void(int)> callback) {
  callback(42);  // 触发回调
  }
  };

  int main() {
  Processor p;

  // 使用 std::bind 把成员函数和 this 绑定成一个可调用对象
  using namespace std::placeholders;  // 需要 _1
  auto bound = std::bind(&Processor::process, &p, _1);

  p.registerCallback(bound);

  return 0;
  }

  //! 方式2： lambda表达式捕获this指针
  class Processor {
  public:
  void process(int value) {
  std::cout << "Processor::process called with " << value << std::endl;
  }

  void registerCallback(std::function<void(int)> callback) {
  callback(100);
  }
  };

  int main() {
  Processor p;

  // lambda 捕获 this，直接调用成员函数
  p.registerCallback([&p](int v) { p.process(v); });

  // 更简洁的写法（C++14 起支持泛型 lambda，可省略参数类型）
  p.registerCallback([&](auto v) { p.process(v); });

  // 或者捕获 this 指针（推荐，语义更明确）
  p.registerCallback([this_ptr = &p](int v) { this_ptr->process(v); });

  return 0;
  }
  {% endhighlight cpp %}

# 零零科技

1. 云台抖动导致使用IOU不准的解决方法
2. 为什么不用mpc做控制？ mpc的原理？
3. 外参标定不准的情况下如何解决跨相机目标匹配？

# 立德空间

1. 全局变量和静态变量的区别
   都存储在内存的静态存储区域

   特性,全局变量 (extern),静态全局变量 (static),静态局部变量 (static)
   生命周期,程序开始到结束,程序开始到结束,程序开始到结束
   作用域,整个工程（跨文件）,仅限当前文件,仅限当前函数内部
   初始化,默认初始化为 0,默认初始化为 0,仅在第一次执行时初始化
2. 什么是多态? 有什么作用?
   - 实现方式
     - 静态多态: 函数重载、模板
     - 动态多态: 通过虚函数virtual 和 继承实现
   - 作用:
     - 解耦: 调用者只需要父类接口，不需要关心底层具体的子类逻辑
     - 可扩展性: 增加新功能时，只需要继承基类并实现虚函数，不需要修改原有的业务逻辑代码
3. ros中怎么做同步的? 如果用软同步系统时间怎么确认的？
   ros:
4. 多线程了解吗? 线程和进程的区别？
   - 进程是资源分配的最小单位，线程是cpu调度的最小单位
   - 进程有独立的地址空间，互相不干扰; 线程共享所属进程的内存空间（一个线程崩了可能导致进程崩溃）
5. ros中如何保证发布频率稳定在固定帧率
   - 回调处理要快，防止消息积压， 此时要减小队列大小

