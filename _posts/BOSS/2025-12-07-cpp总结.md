---
layout:     post
title:      CPP 总结
subtitle:   
date:       2025-12-07
author:     phoenixZ
header-img: /img/oip4.jpg
catalog: true
tags:
    - boss
    - cpp
---
# 关键字

## static关键字

1. 局部变量加static， 存储在全局区域，函数返回后它的值不会改变
2. static 修饰函数限制函数的可见行，以及避免命名冲突
3. 如果修饰类的成员函数， 不依赖对象，不能访问普通成员变量，只能访问static修饰的成员变量

# 智能指针
## shared_ptr
- 引用计数，跟踪当前有多少个shared_ptr实例正在共享和拥有这个对象
- 每当有一个新的实例指向这个对象的时候引用计数+1
- 每当一个shared_ptr被销毁（比如离开了作用阈）或重置时，引用计数-1
- 引用计数清零的时候，调用该对象的析构函数自动释放被管理对象占用的内存

# 算法

## A_star

{% highlight cpp %}
    struct Node
    {
        int x, y; //坐标
        long long g_score, f_score;

        Node *parent;

        Node(int x1, int y1)
            : x(x1), y(y1)
        {
            g_score = numeric_limits<long long>::max();
            f_score = numeric_limits<long long>::max();
        }
    };

    using PQElement = pair<long long, Node *>;

    int Hfunction(Node *A, Node *B)
    {
        return abs(A->x - B->x) + abs(A->y - B->y);
    }

    void AStar(vector<vector<int>> &map, pair<int, int> start, pair<int, int> end, vector<pair<int, int>> &path)
    {
        int R = map.size(), C = map[0].size();

        vector<vector<Node>> nodes(R);

        for (int i = 0; i < R; i++)
        {
            nodes[i].reserve(C);

            for (int j = 0; j < C; j++)
            {
                nodes[i].emplace_back(i, j);
            }
        }

        priority_queue<PQElement, vector<PQElement>, greater<PQElement>> pq;

        auto start_node = &nodes[start.first][start.second];
        auto target_node = &nodes[end.first][end.second];

        start_node->g_score = 0;
        start_node->f_score = Hfunction(start_node, target_node);

        pq.push({start_node->f_score, start_node});

        while (!pq.empty())
        {
            long long U = pq.top().first;
            auto V = pq.top().second;

            if (U > V->f_score) continue;

            pq.pop();

            if (V == target_node)
            {
                auto tmp = V;
                while (tmp != nullptr)
                {
                    path.push_back({tmp->x, tmp->y});
                    if (tmp == start_node) break;
                    tmp = tmp->parent;
                }

                reverse(path.begin(), path.end());
                return;
            }

            int dr[4] = {-1, 1, 0, 0};
            int dc[4] = {0, 0, -1, 1};

            for (int i = 0; i < 4; i++)
            {
                int r = V->x + dr[i];
                int c = V->y + dc[i];

                if (r < 0 || r >= R || c < 0 || c >= C) continue;

                auto neighbor = &nodes[r][c];

                if (V->g_score + 1 < neighbor->g_score)
                {
                    neighbor->g_score = V->g_score + 1;
                    neighbor->f_score = V->g_score + 1 + Hfunction(neighbor, target_node);
                    neighbor->parent = V;
                    pq.push({neighbor->f_score, neighbor});
                }
            }
        }
    }

{% endhighlight cpp %}

## 排序

### 冒泡排序

{% highlight cpp %}
    #include `<iostream>`
    #include `<vector>`

    using namespace std;

    void bubbleSort(vector`<int>` &arr)
    {
        int n = arr.size();

    for (int i = 0; i < n - 1; ++i)
        {
            bool swapped = false;

    for (int j = 0; j < n - 1 - i; ++j)
            {
                if (arr[j] > arr[j + 1])
                {
                    swap(arr[j], arr[j + 1]);
                    swapped = true;
                }
            }

    if (!swapped)
                break;
        }
    }

{% endhighlight cpp %}

### 快速排序

{% highlight cpp %}
    int findPartition(vector `<int>` &arr, int low, int high)
    {
        int base = arr[high]; // 选最右边的作为基准

    int i = low - 1;

    for (int j = low; j < high; ++j)
        {
            if (arr[j] <= base)
            {
                ++i;
                swap(arr[i], arr[j]);
            }
        }

    swap(arr[i + 1], arr[high]);

    return i + 1;
    }

    void quickSort(vector`<int>` &arr, int low, int high)
    {
        if (low < high)
        {
            int idx = findPartition(arr, low, high);
            quickSort(arr, low, idx - 1);
            quickSort(arr, idx + 1, high);
        }
    }
{% endhighlight cpp %}

## 二分查找

{% highlight cpp %}
    int binaryFind(vector `<int>` &arr, int left, int right, int target)
    {
        while (left <= right)
        {
            int mid = left + (right - left) / 2;

            if (arr[mid] < target)
            {
                left = mid + 1;
            }

            else if (arr[mid] > target)
            {
                right = mid - 1;
            }

            else
            {
                return mid;
            }
        }

        return -1;
    }
{% endhighlight cpp %}
