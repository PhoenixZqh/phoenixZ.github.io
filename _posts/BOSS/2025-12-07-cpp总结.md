---
layout:     post
title:      CPP 总结
subtitle:   
date:       2025-12-07
author:     phoenixZ
header-img: /img/oip4.jpg
catalog: true
tags:
    - boss
    - cpp
---
# 关键字

## static关键字

1. 局部变量加static， 存储在全局区域，函数返回后它的值不会改变
2. static 修饰函数限制函数的可见行，以及避免命名冲突
3. 如果修饰类的成员函数， 不依赖对象，不能访问普通成员变量，只能访问static修饰的成员变量

# 智能指针

## shared_ptr

- 引用计数，跟踪当前有多少个shared_ptr实例正在共享和拥有这个对象
- 每当有一个新的实例指向这个对象的时候引用计数+1
- 每当一个shared_ptr被销毁（比如离开了作用阈）或重置时，引用计数-1
- 引用计数清零的时候，调用该对象的析构函数自动释放被管理对象占用的内存

# 类相关

## 析构函数与构造函数

### 执行顺序

1. 构造函数
- **基类构造函数** ：按照继承列表中的声明顺序执行
- **成员对象构造函数** ：按照类定义中成员变量的声明顺序执行
- **派生类自身的构造函数体**
  

2. 析构函数
- **派生类自身的析构函数体**
- **成员对象析构函数**
- **基类析构函数**

> **重要提醒** ：在多继承或深层继承中，这种“对称性”确保了派生类在销毁时，其依赖的底层基类资源依然有效，直到最后一步才被释放。

### 可以是虚函数吗

构造函数不能是虚函数：如果是虚函数，就需要用虚函数指针去查找虚函数表，但是虚函数指针是在构造函数执行过程中才被初始化；这样虚函数指针是个随机值或者未分配；
析构函数是虚函数：然后先子类再父类的释放顺序，实现完整销毁

## 多态
### 核心组件
1. 虚函数表： 编译器为每一个拥有虚函数的类创建一个静态表格，存放该类所有虚函数的地址
2. 虚函数指针： 编译器在类的每个对象实例中，隐式添加一个指针(通常位于对象内存布局的最开头)， 指向虚函数表
   
### 三个阶段
1. 编译器(建立虚函数表)
2. 对象创建期(关联虚函数表)
3. 运行期(动态寻址)

# STL

## Vector

# 算法

## A_star

{% highlight cpp %}
    struct Node
    {
        int x, y; //坐标
        long long g_score, f_score;

    Node *parent;

    Node(int x1, int y1)
            : x(x1), y(y1)
        {
            g_score = numeric_limits`<long long>`::max();
            f_score = numeric_limits `<long long>`::max();
        }
    };

    using PQElement = pair<long long, Node *>;

    int Hfunction(Node *A, Node *B)
    {
        return abs(A->x - B->x) + abs(A->y - B->y);
    }

    void AStar(vector<vector`<int>`> &map, pair<int, int> start, pair<int, int> end, vector<pair<int, int>> &path)
    {
        int R = map.size(), C = map[0].size();

    vector<vector`<Node>`> nodes(R);

    for (int i = 0; i < R; i++)
        {
            nodes[i].reserve(C);

    for (int j = 0; j < C; j++)
            {
                nodes[i].emplace_back(i, j);
            }
        }

    priority_queue<PQElement, vector`<PQElement>`, greater `<PQElement>`> pq;

    auto start_node = &nodes[start.first][start.second];
        auto target_node = &nodes[end.first][end.second];

    start_node->g_score = 0;
        start_node->f_score = Hfunction(start_node, target_node);

    pq.push({start_node->f_score, start_node});

    while (!pq.empty())
        {
            long long U = pq.top().first;
            auto V = pq.top().second;

    if (U > V->f_score) continue;

    pq.pop();

    if (V == target_node)
            {
                auto tmp = V;
                while (tmp != nullptr)
                {
                    path.push_back({tmp->x, tmp->y});
                    if (tmp == start_node) break;
                    tmp = tmp->parent;
                }

    reverse(path.begin(), path.end());
                return;
            }

    int dr[4] = {-1, 1, 0, 0};
            int dc[4] = {0, 0, -1, 1};

    for (int i = 0; i < 4; i++)
            {
                int r = V->x + dr[i];
                int c = V->y + dc[i];

    if (r < 0 || r >= R || c < 0 || c >= C) continue;

    auto neighbor = &nodes[r][c];

    if (V->g_score + 1 < neighbor->g_score)
                {
                    neighbor->g_score = V->g_score + 1;
                    neighbor->f_score = V->g_score + 1 + Hfunction(neighbor, target_node);
                    neighbor->parent = V;
                    pq.push({neighbor->f_score, neighbor});
                }
            }
        }
    }

{% endhighlight cpp %}

## 排序

### 冒泡排序

{% highlight cpp %}
    #include `<iostream>`
    #include `<vector>`

    using namespace std;

    void bubbleSort(vector`<int>` &arr)
    {
        int n = arr.size();

    for (int i = 0; i < n - 1; ++i)
        {
            bool swapped = false;

    for (int j = 0; j < n - 1 - i; ++j)
            {
                if (arr[j] > arr[j + 1])
                {
                    swap(arr[j], arr[j + 1]);
                    swapped = true;
                }
            }

    if (!swapped)
                break;
        }
    }

{% endhighlight cpp %}

### 快速排序

{% highlight cpp %}
    int findPartition(vector `<int>` &arr, int low, int high)
    {
        int base = arr[high]; // 选最右边的作为基准

    int i = low - 1;

    for (int j = low; j < high; ++j)
        {
            if (arr[j] <= base)
            {
                ++i;
                swap(arr[i], arr[j]);
            }
        }

    swap(arr[i + 1], arr[high]);

    return i + 1;
    }

    void quickSort(vector`<int>` &arr, int low, int high)
    {
        if (low < high)
        {
            int idx = findPartition(arr, low, high);
            quickSort(arr, low, idx - 1);
            quickSort(arr, idx + 1, high);
        }
    }
{% endhighlight cpp %}

## 二分查找

{% highlight cpp %}
    int binaryFind(vector `<int>` &arr, int left, int right, int target)
    {
        while (left <= right)
        {
            int mid = left + (right - left) / 2;

    if (arr[mid] < target)
            {
                left = mid + 1;
            }

    else if (arr[mid] > target)
            {
                right = mid - 1;
            }

    else
            {
                return mid;
            }
        }

    return -1;
    }
{% endhighlight cpp %}

# lamda表达式
