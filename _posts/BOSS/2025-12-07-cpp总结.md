---
layout:     post
title:      CPP æ€»ç»“
subtitle:   
date:       2025-12-07
author:     phoenixZ
header-img: /img/oip4.jpg
catalog: true
tags:
    - boss
    - cpp
---
# ğŸš€å…³é”®å­—

## ğŸ’¡static

1. å±€éƒ¨å˜é‡åŠ staticï¼Œ å­˜å‚¨åœ¨å…¨å±€åŒºåŸŸï¼Œå‡½æ•°è¿”å›åå®ƒçš„å€¼ä¸ä¼šæ”¹å˜
2. static ä¿®é¥°å‡½æ•°é™åˆ¶å‡½æ•°çš„å¯è§è¡Œï¼Œä»¥åŠé¿å…å‘½åå†²çª
3. å¦‚æœä¿®é¥°ç±»çš„æˆå‘˜å‡½æ•°ï¼Œ ä¸ä¾èµ–å¯¹è±¡ï¼Œä¸èƒ½è®¿é—®æ™®é€šæˆå‘˜å˜é‡ï¼Œåªèƒ½è®¿é—®staticä¿®é¥°çš„æˆå‘˜å˜é‡

# ğŸš€æ™ºèƒ½æŒ‡é’ˆ

## ğŸ’¡shared_ptr

- å¼•ç”¨è®¡æ•°ï¼Œå½“shared_ptrè¢«æ‹·è´(å¢åŠ æ‹¥æœ‰è€…)æˆ–é”€æ¯æ—¶ï¼Œè®¡æ•°æ‰æ”¹å˜
- æ¯å½“æœ‰ä¸€ä¸ªæ–°çš„å®ä¾‹æŒ‡å‘è¿™ä¸ªå¯¹è±¡çš„æ—¶å€™å¼•ç”¨è®¡æ•°+1
- æ¯å½“ä¸€ä¸ªshared_ptrè¢«é”€æ¯ï¼ˆæ¯”å¦‚ç¦»å¼€äº†ä½œç”¨é˜ˆï¼‰æˆ–é‡ç½®æ—¶ï¼Œå¼•ç”¨è®¡æ•°-1
- å¼•ç”¨è®¡æ•°æ¸…é›¶çš„æ—¶å€™ï¼Œè°ƒç”¨è¯¥å¯¹è±¡çš„ææ„å‡½æ•°è‡ªåŠ¨é‡Šæ”¾è¢«ç®¡ç†å¯¹è±¡å ç”¨çš„å†…å­˜
- å¾ªç¯å¼•ç”¨çš„é—®é¢˜: ä¸¤ä¸ªå¯¹è±¡äº’ç›¸æŒæœ‰å¯¹æ–¹çš„shared_ptr, è®¡æ•°æ— æ³•æ¸…é›¶ï¼Œä»è€Œå¼•å‘å†…å­˜æ³„æ¼çš„é—®é¢˜

# ğŸš€ç±»ç›¸å…³

## ğŸ’¡ææ„å‡½æ•°ä¸æ„é€ å‡½æ•°

### æ‰§è¡Œé¡ºåº

1. æ„é€ å‡½æ•°

- **åŸºç±»æ„é€ å‡½æ•°** ï¼šæŒ‰ç…§ç»§æ‰¿åˆ—è¡¨ä¸­çš„å£°æ˜é¡ºåºæ‰§è¡Œ
- **æˆå‘˜å¯¹è±¡æ„é€ å‡½æ•°** ï¼šæŒ‰ç…§ç±»å®šä¹‰ä¸­æˆå‘˜å˜é‡çš„å£°æ˜é¡ºåºæ‰§è¡Œ
- **æ´¾ç”Ÿç±»è‡ªèº«çš„æ„é€ å‡½æ•°ä½“**

2. ææ„å‡½æ•°

- **æ´¾ç”Ÿç±»è‡ªèº«çš„ææ„å‡½æ•°ä½“**
- **æˆå‘˜å¯¹è±¡ææ„å‡½æ•°**
- **åŸºç±»ææ„å‡½æ•°**

> **é‡è¦æé†’** ï¼šåœ¨å¤šç»§æ‰¿æˆ–æ·±å±‚ç»§æ‰¿ä¸­ï¼Œè¿™ç§â€œå¯¹ç§°æ€§â€ç¡®ä¿äº†æ´¾ç”Ÿç±»åœ¨é”€æ¯æ—¶ï¼Œå…¶ä¾èµ–çš„åº•å±‚åŸºç±»èµ„æºä¾ç„¶æœ‰æ•ˆï¼Œç›´åˆ°æœ€åä¸€æ­¥æ‰è¢«é‡Šæ”¾ã€‚

### å¯ä»¥æ˜¯è™šå‡½æ•°å—

æ„é€ å‡½æ•°ä¸èƒ½æ˜¯è™šå‡½æ•°ï¼šå¦‚æœæ˜¯è™šå‡½æ•°ï¼Œå°±éœ€è¦ç”¨è™šå‡½æ•°æŒ‡é’ˆå»æŸ¥æ‰¾è™šå‡½æ•°è¡¨ï¼Œä½†æ˜¯è™šå‡½æ•°æŒ‡é’ˆæ˜¯åœ¨æ„é€ å‡½æ•°æ‰§è¡Œè¿‡ç¨‹ä¸­æ‰è¢«åˆå§‹åŒ–ï¼›è¿™æ ·è™šå‡½æ•°æŒ‡é’ˆæ˜¯ä¸ªéšæœºå€¼æˆ–è€…æœªåˆ†é…ï¼›
ææ„å‡½æ•°æ˜¯è™šå‡½æ•°ï¼šç„¶åå…ˆå­ç±»å†çˆ¶ç±»çš„é‡Šæ”¾é¡ºåºï¼Œå®ç°å®Œæ•´é”€æ¯

## ğŸ’¡å¤šæ€

### æ ¸å¿ƒç»„ä»¶

1. è™šå‡½æ•°è¡¨ï¼š ç¼–è¯‘å™¨ä¸ºæ¯ä¸€ä¸ªæ‹¥æœ‰è™šå‡½æ•°çš„ç±»åˆ›å»ºä¸€ä¸ªé™æ€è¡¨æ ¼ï¼Œå­˜æ”¾è¯¥ç±»æ‰€æœ‰è™šå‡½æ•°çš„åœ°å€
2. è™šå‡½æ•°æŒ‡é’ˆï¼š ç¼–è¯‘å™¨åœ¨ç±»çš„æ¯ä¸ªå¯¹è±¡å®ä¾‹ä¸­ï¼Œéšå¼æ·»åŠ ä¸€ä¸ªæŒ‡é’ˆ(é€šå¸¸ä½äºå¯¹è±¡å†…å­˜å¸ƒå±€çš„æœ€å¼€å¤´)ï¼Œ æŒ‡å‘è™šå‡½æ•°è¡¨

### ä¸‰ä¸ªé˜¶æ®µ

1. ç¼–è¯‘å™¨(å»ºç«‹è™šå‡½æ•°è¡¨)
2. å¯¹è±¡åˆ›å»ºæœŸ(å…³è”è™šå‡½æ•°è¡¨)
3. è¿è¡ŒæœŸ(åŠ¨æ€å¯»å€)

# ğŸš€STL

## ğŸ’¡Vector

# ğŸš€ç®—æ³•

## ğŸ’¡A_star

{% highlight cpp %}
    struct Node
    {
        int x, y; //åæ ‡
        long long g_score, f_score;

    Node *parent;

    Node(int x1, int y1)
            : x(x1), y(y1)
        {
            g_score = numeric_limits`<long long>`::max();
            f_score = numeric_limits `<long long>`::max();
        }
    };

    using PQElement = pair<long long, Node *>;

    int Hfunction(Node *A, Node *B)
    {
        return abs(A->x - B->x) + abs(A->y - B->y);
    }

    void AStar(vector<vector`<int>`> &map, pair<int, int> start, pair<int, int> end, vector<pair<int, int>> &path)
    {
        int R = map.size(), C = map[0].size();

    vector<vector`<Node>`> nodes(R);

    for (int i = 0; i < R; i++)
        {
            nodes[i].reserve(C);

    for (int j = 0; j < C; j++)
            {
                nodes[i].emplace_back(i, j);
            }
        }

    priority_queue<PQElement, vector`<PQElement>`, greater `<PQElement>`> pq;

    auto start_node = &nodes[start.first][start.second];
        auto target_node = &nodes[end.first][end.second];

    start_node->g_score = 0;
        start_node->f_score = Hfunction(start_node, target_node);

    pq.push({start_node->f_score, start_node});

    while (!pq.empty())
        {
            long long U = pq.top().first;
            auto V = pq.top().second;

    if (U > V->f_score) continue;

    pq.pop();

    if (V == target_node)
            {
                auto tmp = V;
                while (tmp != nullptr)
                {
                    path.push_back({tmp->x, tmp->y});
                    if (tmp == start_node) break;
                    tmp = tmp->parent;
                }

    reverse(path.begin(), path.end());
                return;
            }

    int dr[4] = {-1, 1, 0, 0};
            int dc[4] = {0, 0, -1, 1};

    for (int i = 0; i < 4; i++)
            {
                int r = V->x + dr[i];
                int c = V->y + dc[i];

    if (r < 0 || r >= R || c < 0 || c >= C) continue;

    auto neighbor = &nodes[r][c];

    if (V->g_score + 1 < neighbor->g_score)
                {
                    neighbor->g_score = V->g_score + 1;
                    neighbor->f_score = V->g_score + 1 + Hfunction(neighbor, target_node);
                    neighbor->parent = V;
                    pq.push({neighbor->f_score, neighbor});
                }
            }
        }
    }

{% endhighlight cpp %}

## ğŸ’¡æ’åº

### å†’æ³¡æ’åº

{% highlight cpp %}
    #include `<iostream>`
    #include `<vector>`

    using namespace std;

    void bubbleSort(vector`<int>` &arr)
    {
        int n = arr.size();

    for (int i = 0; i < n - 1; ++i)
        {
            bool swapped = false;

    for (int j = 0; j < n - 1 - i; ++j)
            {
                if (arr[j] > arr[j + 1])
                {
                    swap(arr[j], arr[j + 1]);
                    swapped = true;
                }
            }

    if (!swapped)
                break;
        }
    }

{% endhighlight cpp %}

### å¿«é€Ÿæ’åº

{% highlight cpp %}
    int findPartition(vector `<int>` &arr, int low, int high)
    {
        int base = arr[high]; // é€‰æœ€å³è¾¹çš„ä½œä¸ºåŸºå‡†

    int i = low - 1;

    for (int j = low; j < high; ++j)
        {
            if (arr[j] <= base)
            {
                ++i;
                swap(arr[i], arr[j]);
            }
        }

    swap(arr[i + 1], arr[high]);

    return i + 1;
    }

    void quickSort(vector`<int>` &arr, int low, int high)
    {
        if (low < high)
        {
            int idx = findPartition(arr, low, high);
            quickSort(arr, low, idx - 1);
            quickSort(arr, idx + 1, high);
        }
    }
{% endhighlight cpp %}

## ğŸ’¡äºŒåˆ†æŸ¥æ‰¾

{% highlight cpp %}
    int binaryFind(vector `<int>` &arr, int left, int right, int target)
    {
        while (left <= right)
        {
            int mid = left + (right - left) / 2;

    if (arr[mid] < target)
            {
                left = mid + 1;
            }

    else if (arr[mid] > target)
            {
                right = mid - 1;
            }

    else
            {
                return mid;
            }
        }

    return -1;
    }
{% endhighlight cpp %}

# ğŸš€æ–°ç‰¹æ€§

## ğŸ’¡function

### è§£å†³ä»€ä¹ˆé—®é¢˜ï¼Ÿ

æ˜¯ä¸€ä¸ªé€šç”¨çš„å‡½æ•°åŒ…è£…å™¨ï¼Œç”¨äºç»Ÿä¸€å¤„ç†å„ç§å¯è°ƒç”¨å¯¹è±¡
å¯è°ƒç”¨å¯¹è±¡åŒ…æ‹¬ï¼š

1. æ™®é€šå‡½æ•°
2. ä»¿å‡½æ•°
3. lambdaè¡¨è¾¾å¼
4. ç±»çš„æˆå‘˜å‡½æ•°

### åº•å±‚åŸç†

std::functionçš„å®ç°ä¾èµ–ç±»å‹æ“¦é™¤ï¼Œä¸»è¦é€šè¿‡ä»¥ä¸‹æ–¹å¼å®ç°å¤šæ€

- æŠ½è±¡åŸºç±»+è™šå‡½æ•°ï¼šå†…éƒ¨å®šä¹‰ä¸€ä¸ªæŠ½è±¡åŸºç±»ï¼Œä¸ºæ¯ä¸ªå…·ä½“è°ƒç”¨çš„ç±»å‹ç”Ÿæˆæ´¾ç”Ÿç±»æ¨¡æ¿ï¼Œå­˜å‚¨å®é™…å¯¹è±¡å¹¶å®ç°è°ƒç”¨ã€å¤åˆ¶ã€ææ„
- æ‰‹åŠ¨è™šè¡¨ï¼šé¿å…RTTIå¼€é”€ï¼Œä½¿ç”¨å‡½æ•°æŒ‡é’ˆæ•°ç»„æ¨¡æ‹Ÿè™šè¡¨ï¼Œç®¡ç†è°ƒç”¨ã€å¤åˆ¶ã€ææ„ç­‰æ“ä½œ
- å†…å­˜ç®¡ç†ï¼šå°å¯¹è±¡ä¼˜åŒ–(SBO)å‡å°‘å †åˆ†é…

ç®€å•ç†è§£ï¼šåˆ©ç”¨ç±»å‹æ“¦é™¤+å‡½æ•°æŒ‡é’ˆ/è™šè¡¨å®ç°çš„ä¸€ç§è¿è¡Œæ—¶å¤šæ€

**ç±»å‹æ“¦é™¤**ï¼šç”¨äºéšè—å¯¹è±¡çš„å…·ä½“ç±»å‹ä¿¡æ¯ï¼Œä»è€Œè®©ä¸åŒç±»å‹çš„å¯¹è±¡å¯ä»¥é€šè¿‡ç»Ÿä¸€çš„æ¥å£æ¥æ“ä½œ
**RTTI**ï¼š æ˜¯è¿è¡Œæ—¶ç±»å‹ä¿¡æ¯çš„ç¼©å†™

### ä»£ç ç¤ºä¾‹
{% highlight cpp %}
#include <iostream>
#include <functional> //é…å¥—çš„å¤´æ–‡ä»¶

int add(int a, int b)
{
    return a + b;
}

struct Test
{
    int operator()(int a, int b)
    {
        return a * b;
    }
};

class Robot
{
public:
    void sayHello(std::string name)
    {
        std::cout << "Robot says: Hello, " << name << std::endl;
    }
};

void TestCB(int a, std::function<void(bool)> callback)
{
    bool success = true;
    if (callback)
    {
        callback(success);
    }
}

int main()
{
    std::function<int(int, int)> func;

    //! æƒ…å½¢1ï¼š åŒ…è£…æ™®é€šå‡½æ•°
    func = add;
    std::cout << "add : " << func(2, 3) << std::endl;

    //! æƒ…å½¢2ï¼š åŒ…è£…ä»¿å‡½æ•°
    func = Test();
    std::cout << "Test: " << func(1, 2) << std::endl;

    //! æƒ…å½¢3ï¼š åŒ…è£…lambdaè¡¨è¾¾å¼
    func = [](int a, int b) { return a - b; };
    std::cout << "lambda: " << func(33, 24) << std::endl;

    //! æƒ…å½¢4ï¼š åŒ…è£…ç±»çš„æˆå‘˜å‡½æ•°
    Robot robot;
    std::function<void(std::string)> func1 = std::bind(&Robot::sayHello, &robot, std::placeholders::_1);
    func1("test function");

    //! æƒ…å½¢5ï¼šå®ç°å›è°ƒå‡½æ•°
    TestCB(20, [](bool tmp) { std::cout << tmp << std::endl; });

    return 0;
}
{% endhighlight cpp %}

## ğŸ’¡bindç»‘å®šå™¨

### è§£å†³ä»€ä¹ˆé—®é¢˜

å°†å‡½æ•°å¯¹è±¡ä¸å‚æ•°ç»‘å®šåœ¨ä¸€èµ·å½¢æˆæ–°çš„å¯è°ƒç”¨å¯¹è±¡ï¼Œä¾¿äºç®€å•è°ƒç”¨

### åº•å±‚åŸç†

å°†å‚æ•°å­˜å‚¨åœ¨å†…éƒ¨çš„tupleä¸­ï¼Œå¹¶é€šè¿‡æ¨¡æ¿å…ƒå˜æˆåœ¨è°ƒç”¨æ—¶è¿›è¡Œ"å‚æ•°é‡ç»„"

### ç”¨æ³•ç¤ºä¾‹
### ä»£ç ç¤ºä¾‹
{% highlight cpp %}
#include <functional>
#include <iostream>
#include <memory>
#include <string>
#include <vector>

using namespace std;
using namespace std::placeholders;

void Test(int a)
{
    cout << __func__ << "->" << a << endl;
}

class Person {
private:
public:
    int m_a;
    Person() = default;
    Person(int a)
        : m_a(a)
    {
    }

    int operator()(int b)
    {

        return m_a + b;
    }

    void show(int a)
    {
        cout << __func__ << "->" << a << endl;
    }
};

int main()
{ 
    Person p1;

    //ç»‘å®šæ™®é€šå‡½æ•°
    auto f1 = bind(Test, _1);  //_1ä»£è¡¨å ç¬¬ä¸€ä½
    f1(11);

    //ç»‘å®šæˆå‘˜å‡½æ•°
    auto f2 = bind(&Person::show, &p1, 2);
    f2(2);

    //ç»‘å®šæˆå‘˜å˜é‡ï¼ˆpublicï¼‰
    auto f3 = bind(&Person::m_a, &p1);
    f3() = 111;
    cout << p1.m_a << endl;

    return 0;
}
{% endhighlight cpp %}

## ğŸ’¡lamdaè¡¨è¾¾å¼
### åº•å±‚åŸç†
åº•å±‚å®ç°æ˜¯ç”Ÿæˆæœªå‘½åç±»çš„å®ä¾‹ï¼Œé‡è½½operator().

### ä½œç”¨
1. å°±åœ°å®šä¹‰ï¼š ä¸éœ€è¦ä¸ºäº†ä¸€ä¸ªç®€å•çš„é€»è¾‘å•ç‹¬å†™ä¸€ä¸ªå‡½æ•°ï¼Œ ä½¿ä»£ç æ›´åŠ ç´§å‡‘
2. é—­åŒ…èƒ½åŠ›ï¼š èƒ½æ•è·ä¸Šä¸‹æ–‡ä¸­çš„å˜é‡ï¼Œåœ¨å¤„ç†å›è°ƒã€å¼‚æ­¥æ“ä½œã€å¤šçº¿ç¨‹æ—¶éå¸¸å¼ºå¤§
3. ä»£ç å¯è¯»æ€§ï¼š é€»è¾‘ä¸ä½¿ç”¨ä½ç½®ä¸€è‡´ï¼Œå‡å°‘é˜…è¯»ä»£ç çš„æˆæœ¬

### ä»£ç ç¤ºä¾‹
{% highlight cpp %}
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>
#include <map>
#include <string>
#include <thread>
#include <chrono>

// æœºå™¨äººç³»ç»Ÿç±»ï¼šæ¼”ç¤ºå¦‚ä½•åœ¨æˆå‘˜å‡½æ•°ä¸­ä½¿ç”¨ Lambda å’Œ this
class RobotSystem {
public:
    RobotSystem(std::string name) : robot_name_(name), battery_level_(100) {}

    // 1. æˆå‘˜å‡½æ•°å†…çš„ Lambdaï¼šå¿…é¡»æ•è· [this] æ‰èƒ½è®¿é—®ç±»æˆå‘˜
    void startSelfCheck() {
        std::cout << "[System] Starting self-check for " << robot_name_ << "...\n";
        
        auto check_battery = [this]() {
            // è®¿é—®ç§æœ‰å˜é‡ battery_level_
            std::cout << "[Check] Battery is at " << this->battery_level_ << "%" << std::endl;
            if (this->battery_level_ > 20) {
                this->logStatus("Battery OK");
            }
        };
        check_battery();
    }

    void logStatus(std::string status) {
        std::cout << "[Log] " << status << std::endl;
    }

private:
    std::string robot_name_;
    int battery_level_;
};

int main() {
    // --- ç¤ºä¾‹ 1: åŸºç¡€ç”¨æ³• (ç”¨äº STL ç®—æ³•) ---
    std::vector<double> sensor_readings = {1.2, 0.5, 3.8, 2.4};
    
    // ä½¿ç”¨ Lambda è¿›è¡Œé™åºæ’åº
    std::sort(sensor_readings.begin(), sensor_readings.end(), [](double a, double b) {
        return a > b; 
    });

    std::cout << "Sorted Readings: ";
    // ä½¿ç”¨ Lambda æ‰“å°
    std::for_each(sensor_readings.begin(), sensor_readings.end(), [](double d) {
        std::cout << d << " ";
    });
    std::cout << "\n\n";


    // --- ç¤ºä¾‹ 2: é—­åŒ…æ•è· (å€¼æ•è·ä¸å¼•ç”¨æ•è·) ---
    double offset = 0.5;
    double sum = 0;

    // [offset] æ˜¯å€¼æ•è·ï¼šæ‹·è´ä¸€ä»½å‰¯æœ¬ï¼Œå†…éƒ¨ä¸å¯ä¿®æ”¹å¤–éƒ¨çš„ offset
    // [&sum]   æ˜¯å¼•ç”¨æ•è·ï¼šå†…éƒ¨ç›´æ¥ä¿®æ”¹å¤–éƒ¨å˜é‡ sum çš„å€¼
    std::for_each(sensor_readings.begin(), sensor_readings.end(), [offset, &sum](double val) {
        sum += (val + offset); 
    });
    std::cout << "Sum with offset: " << sum << "\n\n";


    // --- ç¤ºä¾‹ 3: åœ¨ç±»å†…ä½¿ç”¨ (æ•è· this) ---
    RobotSystem myRobot("Standard-Bot");
    myRobot.startSelfCheck();
    std::cout << "\n";


    // --- ç¤ºä¾‹ 4: ç»“åˆ std::function å®ç°æŒ‡ä»¤å›è°ƒ (æœºå™¨äººå¼€å‘å¸¸ç”¨) ---
    std::map<std::string, std::function<void(int)>> command_dispatcher;

    // åŠ¨æ€æ³¨å†Œä¸åŒçš„ Lambda æŒ‡ä»¤
    command_dispatcher["move_forward"] = [](int power) {
        std::cout << "Action: Moving forward with power " << power << std::endl;
    };
    command_dispatcher["rotate"] = [](int angle) {
        std::cout << "Action: Rotating " << angle << " degrees." << std::endl;
    };

    // æ¨¡æ‹Ÿæ¥æ”¶åˆ°å¤–éƒ¨æŒ‡ä»¤
    std::string incoming_cmd = "move_forward";
    if (command_dispatcher.count(incoming_cmd)) {
        command_dispatcher[incoming_cmd](80); // æ‰§è¡Œå¯¹åº”çš„ Lambda
    }

    // --- ç¤ºä¾‹ 5: mutable å…³é”®å­— ---
    int counter = 10;
    // é»˜è®¤å€¼æ•è·ä¸å¯ä¿®æ”¹å‰¯æœ¬ï¼ŒåŠ ä¸Š mutable åå…è®¸åœ¨ Lambda å†…éƒ¨ä¿®æ”¹å‰¯æœ¬å†…å®¹
    auto tick = [counter]() mutable {
        counter++; 
        std::cout << "Internal counter (mutable copy): " << counter << std::endl;
    };
    tick();
    std::cout << "External counter (original): " << counter << " (unchanged)\n";

    return 0;
}
{% endhighlight cpp %}


## ğŸ’¡ç§»åŠ¨æ„é€ 

### ä½œç”¨
1. èµ„æºè½¬ç§»è€Œéæ‹·è´ï¼šå½“ä¸€ä¸ªå¯¹è±¡å³å°†è¢«é”€æ¯æ—¶ï¼Œç§»åŠ¨æ„é€ å¯ä»¥è½¬ç§»å®ƒçš„èµ„æºï¼Œè€Œä¸æ˜¯é‡æ–°åˆ†é…å¹¶å¤åˆ¶ä¸€ä»½
2. æ€§èƒ½æå‡ï¼š å°†O(n)çš„æ‹·è´æ“ä½œé™ä½ä¸ºO(1)çš„æŒ‡é’ˆäº¤æ¢
3. æ”¯æŒä»…å¯ç§»åŠ¨çš„ç±»å‹ï¼š å¦‚unique_ptr æˆ– thread

### ä»£ç ç¤ºä¾‹
{% highlight cpp %}
class RobotData {
public:
    double* data;
    size_t size;

    RobotData(size_t s) : size(s) {
        data = new double[s];
        std::cout << "Allocated memory at " << data << std::endl;
    }

    // ç§»åŠ¨æ„é€ å‡½æ•°
    // æ¥æ”¶ä¸€ä¸ªå³å€¼å¼•ç”¨ RobotData&&
    RobotData(RobotData&& other) noexcept {
        this->data = other.data;  // â€œå·â€èµ°æŒ‡é’ˆ
        this->size = other.size;
        
        other.data = nullptr;     // å°†æºå¯¹è±¡ç½®ç©ºï¼Œé˜²æ­¢ææ„æ—¶é‡Šæ”¾å†…å­˜
        other.size = 0;
        std::cout << "Moved memory to new object" << std::endl;
    }

    ~RobotData() {
        delete[] data;
    }

    // ç¦æ­¢æ‹·è´æ„é€ ï¼ˆä¸ºäº†æ¼”ç¤ºç§»åŠ¨ï¼‰
    RobotData(const RobotData&) = delete;
};

int main() {
    std::vector<RobotData> vec;
    // æ­¤æ—¶ä¼šè°ƒç”¨ç§»åŠ¨æ„é€ å‡½æ•°ï¼Œè€Œä¸æ˜¯æ˜‚è´µçš„æ‹·è´
    vec.push_back(RobotData(1000)); 
    return 0;
}
{% endhighlight cpp %}

## ğŸ’¡å®Œç¾è½¬å‘
### ä½œç”¨

1. ä¿æŒå±æ€§ä¸å˜ï¼šåœ¨ç¼–å†™æ¨¡æ¿å‡½æ•°æ—¶ï¼Œå°†å‚æ•°åŸå°ä¸åŠ¨åœ°ä¼ é€’ç»™å†…éƒ¨å‡½æ•°ã€‚
2. è§£å†³ç—›ç‚¹ï¼šå¦‚æœå‚æ•°æ˜¯å·¦å€¼ï¼Œä¼ ç»™å†…éƒ¨ä¹Ÿæ˜¯å·¦å€¼ï¼›å¦‚æœæ˜¯å³å€¼ï¼Œä¼ ç»™å†…éƒ¨ä¾ç„¶æ˜¯å³å€¼
3. å®ç°åŸºç¡€ï¼šä¾èµ–äº ä¸‡èƒ½å¼•ç”¨ï¼ˆUniversal Reference, T&&ï¼‰ å’Œ std::forward<T>

### ä»£ç ç¤ºä¾‹
{% highlight cpp %}
#include <iostream>
#include <utility>

void process(int& x) { std::cout << "Lvalue processed\n"; }
void process(int&& x) { std::cout << "Rvalue processed\n"; }

// å®Œç¾è½¬å‘åŒ…è£…å™¨
template<typename T>
void logAndProcess(T&& arg) {
    std::cout << "Logging... ";
    // std::forward<T>(arg) ä¼šæ ¹æ® T çš„ç±»å‹å†³å®šè½¬å‘å·¦å€¼è¿˜æ˜¯å³å€¼
    process(std::forward<T>(arg)); 
}

int main() {
    int a = 10;
    logAndProcess(a);  // ä¼ å…¥å·¦å€¼ -> è°ƒç”¨ process(int&)
    logAndProcess(20); // ä¼ å…¥å³å€¼ -> è°ƒç”¨ process(int&&)
    return 0;
}
{% endhighlight cpp %}

# ğŸš€å†…å­˜ç®¡ç†

# ğŸš€æ“ä½œç³»ç»Ÿ

## ğŸ’¡è¿›ç¨‹å’Œçº¿ç¨‹
### è¿›ç¨‹å’Œçº¿ç¨‹çš„åŒºåˆ«

1. åŸºæœ¬æ¦‚å¿µ
   - è¿›ç¨‹æ˜¯ç³»ç»Ÿè¿›è¡Œèµ„æºåˆ†é…å’Œè°ƒåº¦çš„åŸºæœ¬å•ä½ï¼Œæ‹¥æœ‰ç‹¬ç«‹çš„å†…å­˜ç©ºé—´åœ°å€
   - çº¿ç¨‹æ˜¯CPUè¿›è¡Œè°ƒåº¦å’Œåˆ†é…çš„ï¼Œå…±äº«æ‰€å±è¿›ç¨‹çš„èµ„æº
2. åŒºåˆ«
   - è¿›ç¨‹æ‹¥æœ‰èµ„æºï¼Œçº¿ç¨‹ä¸æ‹¥æœ‰èµ„æº
   - è¿›ç¨‹é—´é€šä¿¡å¼€é”€å¤§ï¼Œçº¿ç¨‹é—´é€šä¿¡ç®€å•
   - ä¸€ä¸ªè¿›ç¨‹å´©äº†ä¸ä¼šå½±å“å…¶ä»–çº¿ç¨‹ï¼Œä½†æ˜¯ä¸€ä¸ªçº¿ç¨‹å´©äº†æ•´ä¸ªè¿›ç¨‹å¯èƒ½éƒ½ä¼šé€€å‡º

### è¿›ç¨‹å’Œçº¿ç¨‹çš„é€šä¿¡æ–¹å¼

1. è¿›ç¨‹é€šä¿¡æ–¹å¼
   - ç®¡é“ï¼šåŠåŒå·¥
   - ä¿¡å·ï¼šç®€å•çš„å¼‚æ­¥é€šçŸ¥æœºåˆ¶
   - æ¶ˆæ¯é˜Ÿåˆ—ï¼šå…‹æœäº†ä¿¡å·è½½è·å°‘ã€ç®¡é“æ— æ ¼å¼çš„ç¼ºç‚¹
   - å…±äº«å†…å­˜ï¼šæœ€å¿«çš„æ–¹å¼ï¼Œä½†éœ€è¦æ³¨æ„åŒæ­¥
   - å¥—æ¥å­—(socket)ï¼šå¯è·¨æœºå™¨é€šä¿¡
2. çº¿ç¨‹é€šä¿¡æ–¹å¼
   - å…±äº«å…¨å±€å˜é‡
   - ä¿¡å·é‡
   - æ¡ä»¶å˜é‡
   - å¥—æ¥å­—

## ğŸ’¡é”
### æ­»é”
1. äº§ç”ŸåŸå› ï¼Ÿ
   - ä¸¤ä¸ªæˆ–è€…å¤šä¸ªè¿›ç¨‹åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œå› äº‰å¤ºèµ„æºè€Œé€ æˆçš„ä¸€ç§äº’ç›¸ç­‰å¾…çš„ç°è±¡
2. æ­»é”äº§ç”Ÿçš„å¿…è¦æ¡ä»¶
   - äº’æ–¥æ¡ä»¶ï¼šèµ„æºåŒä¸€æ—¶é—´åªèƒ½è¢«ä¸€ä¸ªè¿›ç¨‹å ç”¨
   - è¯·æ±‚ä¸ä¿æŒï¼š å·²å æœ‰èµ„æºï¼ŒåŒæ—¶è¯·æ±‚æ–°èµ„æº
   - ä¸å‰¥å¤ºæ¡ä»¶ï¼š èµ„æºä¸èƒ½è¢«å¼ºåˆ¶æŠ¢å 
   - å¾ªç¯ç­‰å¾…ï¼š å½¢æˆäº†ä¸€ä¸ªè¿›ç¨‹ç­‰å¾…èµ„æºçš„ç¯è·¯
3. è§£å†³æ­»é”
   - ç ´åå››ä¸ªå¿…è¦æ¡ä»¶ä¹‹ä¸€
   - åˆ†é…èµ„æºå‰è¿›è¡Œé£é™©è¯„ä¼°ï¼› é“¶è¡Œå®¶ç®—æ³•
   - å¼ºè¡Œå‰¥å¤ºèµ„æºã€æ€æ­»è¿›ç¨‹
   
### å…¸å‹çš„é”
- äº’æ–¥é”(mutex)ï¼šå¦‚æœé”è¢«å ç”¨ï¼Œçº¿ç¨‹ä¼šè¿›å…¥ç¡çœ ï¼Œäº¤å‡ºCPUç»™å…¶ä»–çº¿ç¨‹ã€‚ç­‰é”é‡Šæ”¾åè¢«å”¤é†’ï¼› ç”¨äºç­‰å¾…æ—¶é—´é•¿ï¼Œä¸å¸Œæœ›æµªè´¹CPUçš„åœºæ™¯ï¼›
- è‡ªæ—‹é”(spinlock)ï¼šå¦‚æœé”è¢«å ç”¨ï¼Œçº¿ç¨‹ä¼šå¾ªç¯å¿™ç­‰(cpuä¸åœç©ºè½¬)ï¼Œç›´åˆ°æ‹¿åˆ°é”ï¼›ç”¨äºç­‰å¾…æ—¶é—´çŸ­çš„åœºæ™¯ï¼Œå› ä¸ºçº¿ç¨‹åˆ‡æ¢çš„å¼€é”€æ¯”å¿™ç­‰è¿˜è¦å¤§ï¼›
