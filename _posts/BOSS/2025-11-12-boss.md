---
layout:     post
title:      项目总结
subtitle:   
date:       2024-11-15
author:     phoenixZ
header-img: /img/oip3.jpg
catalog: true
tags:
    - boss
---
# 航迹飞行区域覆盖

## 区域覆盖

根据区域： 圆形、矩形 取最小的X，Y；

**圆形的话：**

1. 先根据GPS2XYZ，  利用圆心和半径得到 Xmin， Xmax， Ymin， Ymax
2. 根据间隔n米一个点的原则，从左下到左上，S形走位，并且要判断点在不在圆形内(勾股定理， 点与圆心点的平方距离)

**多边形的话：**

1. 直接可以得到Xmin, Ymin
2. 根据间隔n米一个点的原则，判断生成多少个点

{% highlight cpp %}
void algo_search::generatePoints()
{

    all_point.clear();

    int x_count = (xMax - xMin) / per_distance + 1;

    int y_count = (yMax - yMin) / per_distance + 1;

    all_point.emplace_back(xMin, yMin, mission_get.missions[0].height);

    double y_start = yMin;

    for (int j = 1; j <= y_count; ++j)
    {

    y_start += per_distance;

    all_point.emplace_back(xMin, y_start, mission_get.missions[0].height);
    }

    double x_start = xMin;

    for (int i = 1; i <= x_count; ++i)

    {

    x_start += per_distance;

    all_point.emplace_back(x_start, y_start, mission_get.missions[0].height);

    for (int j = 1; j <= y_count; ++j)
        {

    if ((i % 2) == 1)

    {

    y_start -= per_distance;
            }

    else
            {

    y_start += per_distance;
            }

    all_point.emplace_back(x_start, y_start, mission_get.missions[0].height);
        }
    }
}
{% endhighlight %}

## PID

PID 是比例-积分-微分控制

我是这样理解的： 想象有一桶水， 当前水量0.2L, 目标水量1L

**对于比例控制**：

U = Kp * (目标值 - 当前值)， 假设1s加一次水， 一次加0.5L

第一帧：U = 0.5 * 0.8 = 0.4,  diff = 1-0.6 = 0.4
第二帧：U = 0.5 * 0.4 = 0.2,  diff = 1-0.8 = 0.2
第三帧：U = 0.5 * 0.2 = 0.1,  diff = 1-0.9 = 0.1
...

但是如果考虑水缸会漏水的情况，就会有稳态误差的形成， 也就是稳定在0.8L不往上增加了

**这时需要引入积分控制**

U = Kp × diff + Ki × 累积的diff

增加每次的输入，防止稳态误差

**对于微分控制**

U = Kp × diff + Ki × 累积的diff + Kp*(diff / dt)

微分控制主要是防止震荡

{% highlight cpp %}
float PID::computeVal(const float &cur_status, const float &target_status, const float &delta_t)
{
    float val_p, val_i, val_d, error, res_val;

    error = target_status - cur_status;

    val_p = error;

    val_i += error * delta_t;
    val_d = (error - last_error_) / delta_t;

    last_error_ = error;

    //比例控制 + 积分控制 + 微分控制
    res_val = kp_ * val_p + ki_ * val_i + kd_ * val_d;

    return res_val;
}
{% endhighlight %}

# 目标跟随与防丢失策略

## 模型部署

## 卡尔曼滤波

卡尔曼滤波器是一种用于**线性**系统状态估计的递归算法。它通过融合带有噪声的测量值和一个包含系统动态的预测模型，来产生对系统状态的最优估计。这里的“最优”是指在最小均方误差 (Minimum Mean Square Error, MMSE) 意义下。

### 核心假设

1. **系统是线性的。**
2. **过程噪声和测量噪声是零均值、高斯分布（正态分布）的白噪声。**

### 1. 系统模型 (System Model)

一个离散时间线性系统可以表示为：

* 状态转移方程 (Prediction):
  $$
  x_k = F_{k-1} x_{k-1} + B_{k-1} u_{k-1} + w_{k-1}
  $$
* 测量方程 (Update):
  $$
  z_k = H_k x_k + v_k
  $$

| **符号**        | **描述**                                                                           |
| --------------------- | ---------------------------------------------------------------------------------------- |
| **$x_k$**     | **$k$**时刻的**系统状态向量**                                              |
| **$x_{k-1}$** | **$k-1$**时刻的系统状态向量                                                            |
| **$F_{k-1}$** | **状态转移矩阵**(或 **系统矩阵** )，将**$x_{k-1}$**映射到**$x_k$** |
| **$u_{k-1}$** | **$k-1$**时刻的**控制输入向量**                                            |
| **$B_{k-1}$** | **控制输入矩阵**(或 **控制矩阵** )，将**$u_{k-1}$**映射到**$x_k$** |
| **$w_{k-1}$** | **过程噪声向量** ，假设**$w_{k-1} \sim N(0, Q_{k-1})$**                          |
| **$Q_{k-1}$** | **过程噪声协方差矩阵**                                                             |
| **$z_k$**     | **$k$**时刻的**测量向量**                                                  |
| **$H_k$**     | **观测矩阵**(或 **测量矩阵** )，将**$x_k$**映射到**$z_k$**         |
| **$v_k$**     | **测量噪声向量** ，假设**$v_k \sim N(0, R_k)$**                                  |
| **$R_k$**     | **测量噪声协方差矩阵**                                                             |

### 2. 核心公式 (Recursive Steps)

KF 包含两个阶段：**预测 (Prediction)** 和  **更新 (Update)** 。

#### A. 预测阶段 (Time Update)

利用系统的动态模型来预测下一时刻的状态和误差协方差。

1. 先验状态估计 (Predicted State Estimate):
   $$
   \hat{x}_k^- = F_{k-1} \hat{x}_{k-1}^+ + B_{k-1} u_{k-1}
   $$
2. 先验误差协方差 (Predicted Covariance Estimate):
   $$
   P_k^- = F_{k-1} P_{k-1}^+ F_{k-1}^T + Q_{k-1}
   $$

| **符号**                | **描述**                                                              |
| ----------------------------- | --------------------------------------------------------------------------- |
| **$\hat{x}_k^-$**     | **$k$**时刻的**先验**状态估计 (未结合**$z_k$**测量值)       |
| **$\hat{x}_{k-1}^+$** | **$k-1$**时刻的**后验**状态估计 (已结合**$z_{k-1}$**测量值) |
| **$P_k^-$**           | **$k$**时刻的**先验**误差协方差矩阵                           |
| **$P_{k-1}^+$**       | **$k-1$**时刻的**后验**误差协方差矩阵                         |

#### B. 更新阶段 (Measurement Update)

利用当前时刻的测量值 **$z_k$** 来修正先验估计，得到更准确的后验估计。

1. 卡尔曼增益 (Kalman Gain):
   $$
   K_k = P_k^- H_k^T (H_k P_k^- H_k^T + R_k)^{-1}
   $$
2. 后验状态估计 (Updated State Estimate):
   $$
   \hat{x}_k^+ = \hat{x}_k^- + K_k (z_k - H_k \hat{x}_k^-)
   $$
3. 后验误差协方差 (Updated Covariance Estimate):
   $$
   P_k^+ = (I - K_k H_k) P_k^-
   $$

| **符号**            | **描述**                                                        |
| ------------------------- | --------------------------------------------------------------------- |
| **$K_k$**         | **卡尔曼增益矩阵** ，用于平衡预测和测量之间的权重               |
| **$\hat{x}_k^+$** | **$k$**时刻的**后验**状态估计 (已结合**$z_k$**测量值) |
| **$P_k^+$**       | **$k$**时刻的**后验**误差协方差矩阵                     |
| **$I$**           | 适当维度的**单位矩阵**                                          |

## EKF

当系统模型（状态转移方程或测量方程，或两者）是**非线性**时，标准的 KF 就不能直接使用了。EKF 是 KF 针对非线性系统的一种近似解决方案。

### 核心思想

EKF 的核心思想是：在每次状态预测和测量更新时，用**一阶泰勒级数展开**来近似非线性系统，从而将非线性问题 **局部线性化** ，然后应用标准的 KF 公式。

### 1. 系统模型 (Nonlinear System Model)

非线性离散时间系统可以表示为：

* 状态转移方程 (Prediction):
  $$
  x_k = f(x_{k-1}, u_{k-1}) + w_{k-1}
  $$
* 测量方程 (Update):
  $$
  z_k = h(x_k) + v_k
  $$

| **符号**         | **描述**               |
| ---------------------- | ---------------------------- |
| **$f(\cdot)$** | **非线性**状态转移函数 |
| **$h(\cdot)$** | **非线性**测量函数     |

### 2. 核心公式 (Recursive Steps for EKF)

EKF 最大的区别在于，它用**雅可比矩阵** (Jacobian Matrix) 来代替 KF 中的 **$F$** 和 **$H$** 矩阵。

#### A. 预测阶段 (Time Update)

1. 先验状态估计:

   $$
   \hat{x}_k^- = f(\hat{x}_{k-1}^+, u_{k-1})
   $$

   (注意：这里直接将后验状态估计 $\hat{x}_{k-1}^+$ 代入非线性函数 $f$。)
2. 线性化：计算状态转移雅可比矩阵 $F_{k-1}$，这是 $f(\cdot)$ 关于状态 $x$ 的偏导数。

   $$
   F_{k-1} = \left.\frac{\partial f}{\partial x}\right|_{\hat{x}_{k-1}^+, u_{k-1}}
   $$
3. 先验误差协方差:

   $$
   P_k^- = F_{k-1} P_{k-1}^+ F_{k-1}^T + Q_{k-1}
   $$

   (公式结构与 KF 相同，但 $F_{k-1}$ 是雅可比矩阵。)

#### B. 更新阶段 (Measurement Update)

1. 线性化：计算观测雅可比矩阵 $H_k$，这是 $h(\cdot)$ 关于状态 $x$ 的偏导数。

   $$
   H_k = \left.\frac{\partial h}{\partial x}\right|_{\hat{x}_k^-}
   $$

   (在预测状态 $\hat{x}_k^-$ 处进行线性化。)
2. 卡尔曼增益:

   $$
   K_k = P_k^- H_k^T (H_k P_k^- H_k^T + R_k)^{-1}
   $$

   (公式结构与 KF 相同，但 $H_k$ 是雅可比矩阵。)
3. 后验状态估计:

   $$
   \hat{x}_k^+ = \hat{x}_k^- + K_k (z_k - h(\hat{x}_k^-))
   $$

   (注意：这里的测量残差是用实际测量 $z_k$ 减去通过非线性函数 $h(\cdot)$ 得到的预测测量。)
4. 后验误差协方差:

   $$
   P_k^+ = (I - K_k H_k) P_k^-
   $$

## 单目测距

### 相机模型

#### 1. 像素坐标转图像坐标

将像素坐标 (u, v) 转换为图像坐标 (x, y) 的过程如下：

![像素与图像坐标系示意图]({{ site.baseurl }}/img/像素转图像.png)

数学表达式为：

$$
\left\{
\begin{array}{l}
  x = \frac{u - u_0}{d_x} \\[8pt]
  y = \frac{v - v_0}{d_y} \tag{1}
\end{array}
\right.
$$

> 说明：
> UV 为像素坐标系，XY 为图像坐标系。
> o是图像中心
> (u, v) 表示原始像素坐标，(x, y) 表示转换后的图像坐标；d_x 与 d_y 分别为像素的尺寸。

---

#### 2. 图像坐标转相机坐标

图像坐标转换为相机坐标的示意如下：

![图像坐标转相机坐标]({{ site.baseurl }}/img/图像转相机.png)

转换公式基于相似三角形原理为：

$$
\left\{
\begin{array}{l}
  x_c = \frac{Z_c \cdot x}{f} \\[8pt]
  y_c = \frac{Z_c \cdot y}{f} \tag{1}
\end{array}
\right.
$$

> 说明：
> – 公式中 Z_c 表示相机与目标之间的距离； 在相机坐标系中是沿相机Z轴的距离
> – 在归一化坐标系下，f 的影响可以忽略，从而简化转换过程。

### 测距算法

![测距模型]({{ site.baseurl }}/img/测距模型.png)

#### 1. 计算公式

$$
\begin{aligned}
D      &= H \cdot \tan(\alpha - \beta) \quad \text{(1)} \\[8pt]
\alpha &= \frac{\pi}{2} - pitch \quad \text{(2)} \\[8pt]
\beta  &= \arctan(y) \quad \text{(3)}
\end{aligned}
$$

> **角度说明：**
> **$\alpha$**：相机光轴与水平面的夹角。当云台 pitch 角向下倾斜时，$\alpha = \frac{\pi}{2} - pitch$ 表示从水平线到相机光轴的角度。
> **$\beta$**：从相机光轴到图像上目标投影点的角度。在相机坐标系中，该角度由归一化后的图像坐标 $y$ 计算得到，$\beta = \arctan(y)$。
> 因此，$(\alpha - \beta)$ 表示从水平线到目标投影点的角度，用于计算目标在水平方向上的距离。

#### 2. bata计算原理

![β 图]({{ site.baseurl }}/img/β.png)

> 图中：0 表示光心，p 为图像上的投影点

下面让我解释一下 $\beta$ 角的计算原理：

在相机成像原理中，$\beta$ 角表示从相机光心指向图像平面上某投影点的角度，该角度可以通过图像坐标 $y$ 来计算。

**为什么 $\beta = \arctan(y)$？**原因如下：

1. 图像坐标系中的 $y$ 值已通过相机内参矩阵归一化处理。
2. 因此，$\beta$ 就是该三角形中的角，其计算公式自然为 $\arctan(y)$。

#### 3. 计算深度

根据上述公式 (1)，D 表示 FLU 坐标系中向前的距离（对应于 flu_x）。

利用 flu_x 和勾股定理，可进一步计算深度（实际距离）：

$$
depth = \sqrt{flu_x^2 + H^2}.
$$

#### 4. 计算 yaw 角

![yaw 图]({{ site.baseurl }}/img/yaw.png)

> 正确的 yaw 角应为绿色虚线与 Zc 的夹角, 即是相机坐标系下真实目标与光心的夹角

$$
\begin{aligned}
yaw &= \arctan\left(\frac{flu_y}{flu_x}\right) \\[8pt]
    &= \arctan\left(\frac{y \cdot dist}{flu_x}\right).
\end{aligned}
$$

#### 总结

1. 利用几何关系解算位置 FLU_x = H * tan(云台向下的角度 + 接地点在图像平面投影点与相机光轴的夹角)
2. 接地点在图像平面投影点与相机光轴的夹角可以用 atan(y) 计算得到 (pitch)
3. 然后计算深度， 根据勾股定理， depth = H 平方 + FLU_x的平方然后开方
4. 计算相机坐标系下， 目标点与相机光轴的夹角(yaw)
5. 然后利用图像坐标转世界坐标计算FLU_y， 用图像点X来转换，因为x表示目标点在图像平面偏离光轴的左右程度;
6. 云台控制也利用pitch和yaw将目标保持在画面中心

## 防丢失策略

1. 跟随过程中往前走一段距离
2. 以跟随距离为半径，丢失前的目标点为圆形进行环绕搜索
3. 如果算出来的pitch和yaw接近了阈值就适当抬高、降低无人机

{% highlight cpp %}

void Follow::geratePoints()
{
    circle_angles_.clear();
    float start_angle = atan2(cur_pos_.y - target_pos_.y, cur_pos_.x - target_pos_.x) * (180.0f / M_PI);
    for (int i = 0; i < 360 / std::abs(circle_spd_); ++i) {
        circle_angles_.emplace_back((start_angle + i * circle_spd_) * (M_PI / 180.0f));
    }
    std::reverse(circle_angles_.begin(), circle_angles_.end());
}
{% endhighlight %}

# DJI PSDK

## DJI Eport 替换方案

1. 使用orin NX 作负载的时候， 不用配置USB BULK, 选择硬件连接方式DJI_USE_UART_AND_NETWORK_DEVICE
2. 使用rk3588s 作为负载时，不参照官方建议配置rndis， 直接使用网卡

   - 使用lsusb 获取网卡对应的VID和PID
   - 获取3588对应网口的名称， 修改配置文件对应配置
   - 检查串口名称，eg. `/dev/ttyUSB0`    对应修改hal_uart.h中的 `LINUX_UART_DEV1`

## 双路拉流

1. SDK模块初始化， `DjiCameraManager_Init()` 和 `DjiLiveview_Init()`
2. `DjiPayloadCamera_GetVideoStreamRemoteAddress(ipAddr, &port);`：获取 DJI 负载相机视频流的远程 IP 地址和端口号
3. 可见光、红外同步拉流

   - 启动拉流， 然后用H.264解码
   - 设计队列为帧-时间戳 std::queue<std::pair<cv::Mat, int64_t>>
   - 比较两个队列中最老帧的时间戳，丢弃时间戳较老的帧，直到两个队列的最老帧的时间戳近似相等(误差几ms)

   {% highlight cpp %}

   DjiLiveview_StartH264Stream(DJI_LIVEVIEW_CAMERA_POSITION_NO_1,
   DJI_LIVEVIEW_CAMERA_SOURCE_DEFAULT,
   &StreamDecoder::startMainCameraDecoding);

   DjiLiveview_StartH264Stream(DJI_LIVEVIEW_CAMERA_POSITION_NO_1,
   DJI_LIVEVIEW_CAMERA_SOURCE_M3T_IR,
   &StreamDecoder::startIrCameraDecoding);

   {% endhighlight %}

   {% highlight cpp %}

   bool StreamDecoder::getSynchronizedFrames(cv::Mat& mainFrame, cv::Mat& irFrame, int syncToleranceMs)
   {
   std::lock_guard[std::mutex](std::mutex) lock(frameMutex);
   const int tolerance = syncToleranceMs; // 容忍时间（毫秒）

   // 检查是否有足够的帧进行同步
   while (!mainFrameQueue.empty() && !irFrameQueue.empty())
   {
   // 获取队列头部帧的时间戳
   int64_t mainTs = mainFrameQueue.front().timestamp;
   int64_t irTs   = irFrameQueue.front().timestamp;

   // **注意**：PTS 的单位通常不是毫秒。
   // 例如：long ts_ms = ts * av_q2d(time_base) * 1000;

   long diff = std::abs(mainTs - irTs);

   if (diff <= tolerance)
   {
   // **同步成功**：时间戳匹配，取出帧并返回
   mainFrame = mainFrameQueue.front().frame;
   irFrame   = irFrameQueue.front().frame;

   mainFrameQueue.pop();
   irFrameQueue.pop();

   return true;
   }
   else if (mainTs < irTs)
   {
   std::cout << "Dropping Main Frame. Ts diff: " << diff << "ms." << std::endl;
   mainFrameQueue.pop();
   }
   else // irTs < mainTs
   {
   std::cout << "Dropping IR Frame. Ts diff: " << diff << "ms." << std::endl;
   irFrameQueue.pop();
   }
   }

   // 如果任一队列为空，则无法同步
   return false;
   }

   {% endhighlight %}

## 自定义协议MOP互联互通

1. MOP设置
   - PipelineChannelId 信道值设置为38583
   - PipelineDeviceType 信道设备类型设置为ONBOARD
   - TransmissionControlType 传输控制类型 设置为 UNRELIABLE
2. 智能盒子Mop协议主要由三部分组成：帧头、帧体（负载）、帧尾（校验）
3. 请求信息： fusion_module 0：双光 1. 地图 ， fusion_commad 0：停止 ， 1： 开始； 请求重新发送的图像块
4. 发送信息： ack_type 0： 状态， 1： 图像， data
   - fusion_result_type ：int8_t  表示是什么任务的
   - img_uuid：char 表示图像唯一性
   - seg_nums：uint16_t  图像分段数目
   - seg_current_num：uint16_t 当前分段数
   - seg_img_data：int8_t 当前分段图像内容
5. 解决丢包：
   - 选择性重传
   - 超时未收到ACK自动重传
   - 规定最大重传数和最大等待时间，不行放弃当前帧
   - 图像压缩成JPG格式压缩掉10%， 可以进一步压缩或者使用H.264来压缩

# 多无人车协同搜索

## 边界与视点生成

### 边界生成
1. 合并本车当前探索的区域与其他车形成的区域
2. 如果边界在区域的重叠区域并且当前这个重叠区域的边界不是自由区域或者邻阈没有未知区域，则将边界删除； 同样的原则检查休眠边界；
3. 根据合并区域适当膨胀，但是保证在地图内， 得到新的搜索区域
4. 生成边界种子点   原则： 未被标记为边界 + 所处的位置是自由区域+邻阈未知
   {% highlight cpp %}
    // 获取 SDF 地图的整体边界框
    Vector3d box_min, box_max;
    edt_env_->sdf_map_->getBox(box_min, box_max);

    //定义搜索区域：将更新区域和外部块边界框稍微膨胀
    vector<Eigen::Vector3d> search_mins, search_maxs;
    for (int i = 0; i < mins.size(); ++i)
    {
        search_mins.push_back(mins[i] - Vector3d(1, 1, 0.2));
        search_maxs.push_back(maxs[i] + Vector3d(1, 1, 0.2));

        // 限制范围在sdfmap范围内
        for (int k = 0; k < 3; ++k)
        {
            search_mins[i][k] = max(search_mins[i][k], box_min[k]);
            search_maxs[i][k] = min(search_maxs[i][k], box_max[k]);
        }
    }

    // 将搜索区域的边界框转换为体素索引
    vector<Eigen::Vector3i> min_ids(mins.size()), max_ids(mins.size());
    for (int i = 0; i < mins.size(); ++i)
    {
        edt_env_->sdf_map_->posToIndex(search_mins[i], min_ids[i]);
        edt_env_->sdf_map_->posToIndex(search_maxs[i], max_ids[i]);
    }

    // 在搜索区域内扫描新的边界种子
    for (int i = 0; i < min_ids.size(); ++i)
    {
        auto min_id = min_ids[i];
        auto max_id = max_ids[i];

        for (int z = min_id(2); z <= max_id(2); ++z)
            for (int x = min_id(0); x <= max_id(0); ++x)
                for (int y = min_id(1); y <= max_id(1); ++y)
                {
                    Eigen::Vector3i cur(x, y, z);
                    // 检查条件：
                    // 1. 未标记为边界 (frontier_flag_ == 0)
                    // 2. 当前体素是已知的空闲区域 (knownfree)
                    // 3. 邻居有未知区域 (isNeighborUnknown)

                    if (frontier_flag_[toadr(cur)] == 0 && knownfree(cur) && isNeighborUnknown(cur))
                    {
                        // 从种子单元扩展，生成完整的边界簇
                        expandFrontier(cur, ugv_pos);
                    }
                }
    }
   {% endhighlight %}

5  扩展边界； 利用BFS， 原则： 在4的基础上加了一个地图内的检查
   {% highlight cpp %}
    queue<Eigen::Vector3i> cell_queue;
    vector<Eigen::Vector3d> expanded;
    Vector3d pos;

    edt_env_->sdf_map_->indexToPos(first, pos);
    expanded.push_back(pos);
    cell_queue.push(first);
    frontier_flag_[toadr(first)] = 1;

    // Search frontier cluster based on region growing (distance clustering)
    while (!cell_queue.empty())
    {
        auto cur = cell_queue.front();
        cell_queue.pop();
        auto nbrs = allNeighbors(cur);
        for (auto nbr : nbrs)
        {
            // Qualified cell should be inside bounding box and frontier cell not clustered
            int adr = toadr(nbr);
            if (frontier_flag_[adr] == 1 || !edt_env_->sdf_map_->isInBox(nbr) || !(knownfree(nbr) && isNeighborUnknown(nbr)))
                continue;

            edt_env_->sdf_map_->indexToPos(nbr, pos);

            if (pos[2] < 0.2) continue;

            expanded.push_back(pos);
            cell_queue.push(nbr);
            frontier_flag_[adr] = 1;
        }
    }
   {% endhighlight %}


### 视点生成

   1. 采样位置，以边界为中心点，画三圈半径大小不同的同心圆
   2. 设置条件
      - 必须在地图边界框内（isInBox）
      - 不能在障碍物膨胀区域内（getInflateOccupancy == 1）
      - 不能靠近未知区域（isNearUnknown）
   3. 生成yaw
      - 去降采样后的边界的地一个体素作为参考， 与采样视点作角度计算
      - 然后依次将后面的体素提取出来与采样视点作角度计算并取平均，然后与参考角度累加
      - 这样做的目的： **视野利用率最高，一次能看到最多的未知区域**

   {% highlight cpp %}
      void FrontierFinder::sampleViewpoints(Frontier &frontier)
      {
         // 在圆形区域采样视点
         // 外环控制采样半径
         for (double rc = candidate_rmin_, dr = (candidate_rmax_ - candidate_rmin_) / candidate_rnum_; rc <= candidate_rmax_ + 1e-3; rc += dr)
            // 内循环 控制角度（phi），在 [-π, π) 范围内采样圆周上的点
            for (double phi = -M_PI; phi < M_PI; phi += candidate_dphi_)
            {
                  // 以边界簇平均位置为中心， 画一圈圈同心圆
                  const Vector3d sample_pos = frontier.average_ + rc * Vector3d(cos(phi), sin(phi), 0);

                  // 检查采样点是否合格：
                  // 1. 必须在地图边界框内（isInBox）
                  // 2. 不能在障碍物膨胀区域内（getInflateOccupancy == 1）
                  // 3. 不能靠近未知区域（isNearUnknown）
                  if (!edt_env_->sdf_map_->isInBox(sample_pos) || edt_env_->sdf_map_->getInflateOccupancy(sample_pos) == 1 || isNearUnknown(sample_pos))
                     continue;

                  //* 计算平均yaw角度 */
                  auto &cells = frontier.filtered_cells_; //已知区域和未知区域的边界点（过滤后）
                  // std::cout << "test filter cell: " << cells.size() << std::endl;
                  Eigen::Vector3d ref_dir = (cells.front() - sample_pos).normalized(); // 参考方向：第一个单元到采样点的方向
                  double avg_yaw = 0.0;
                  for (int i = 1; i < cells.size(); ++i)
                  {
                     Eigen::Vector3d dir = (cells[i] - sample_pos).normalized();
                     double yaw = acos(dir.dot(ref_dir));
                     if (ref_dir.cross(dir)[2] < 0)
                        yaw = -yaw;
                     avg_yaw += yaw;
                  }

                  avg_yaw = avg_yaw / cells.size() + atan2(ref_dir[1], ref_dir[0]); // 计算平均偏航角度， 并加上参考方向的初始角度
                  wrapYaw(avg_yaw);                                                 // 规范化到 [-π, π]

                  // 计算从该视点能看到的边界单元数量
                  int visib_num = countVisibleCells(sample_pos, avg_yaw, cells);
                  if (visib_num > min_visib_num_)
                  {
                     Viewpoint vp = {sample_pos, avg_yaw, visib_num};
                     frontier.viewpoints_.push_back(vp);
                     // int gain = findMaxGainYaw(sample_pos, frontier, sample_yaw);
                  }
                  // }
            }
      }

   {% endhighlight %}


## 区域分配算法

## 去中心化方法


## 路径规划

### 全局与局部规划方法

1. 全局： TSP网格巡游
2. 中层： 局部最优视点序列
3. 局部： 前端A*粗略搜路， 重规划给动力学模型规划； 后端优化用B样条插值

### 决定去哪个边界的哪个视点

> 根据网格和边界的情况来生成下一个最佳视点

1. 网格为空
   - 此时要么全局路径走完或者还没规划全局路径
   - 遍历所有边界的最佳视点，这个最佳视点根据能看到最多的边界体素排序的
   - 选效益最大的， **这样做避免摇摆的情况发生**， 如果用cost会忽视掉能看到更多边界的视点，探索效率也会低下
   {% highlight cpp %}
      auto tmp_cost = ViewNode::computeCost(pos, point, yaw[0], ed_->yaws_[i], vel, yaw[1], tmp_path);
      double tmp_utility = 1.0 / (tmp_cost + 1e-3);

      if (tmp_utility > max_utility)
      {
            max_utility = tmp_utility;
            min_cost_id = i;
      }
   {% endhighlight %}

2. 当前网格没有前沿
   - 运动到下一个网格中心，然后再找最近的边界视点

3. 单一边界
   - 精炼视点，挑选排名前几的视点
   - 如果此时已经是最后一个网格了，则挑选cost最低的去
   - 如果还有网格，就把网格位置加入视点数组，然后生成完整的巡游路径，这样做可以更平滑
 
4. 多个前沿
   - 选几个边界，然后在这几个边界中挑选几个排名靠前的视点
   - 然后和三一样用局部巡游路径， Djikstra找访问视点的顺序，A*生成路径

#### 局部巡游的时候图是怎么建立的？             

比如说， 
- 有三个边界，10个视点， 依照分层建图的原则， 第一个边界的所有视点在第一层，但是没有边相连，第一层的节点连接第二层的所有节点； 
- 节点包括：视点位置、最佳朝向，进入该视点的速度，id

{% highlight cpp %}
   for (int i = 0; i < n_points.size(); ++i)
   {
      // Create nodes for viewpoints of one frontier
      for (int j = 0; j < n_points[i].size(); ++j)
      {
         ViewNode::Ptr node(new ViewNode(n_points[i][j], n_yaws[i][j]));
         g_search.addNode(node);
         // Connect a node to nodes in last group
         for (auto nd : last_group)
               g_search.addEdge(nd->id_, node->id_);
         cur_group.push_back(node);

         // Only keep the first viewpoint of the last local frontier
         if (i == n_points.size() - 1)
         {
               final_node = node;
               break;
         }
      }
      // Store nodes for this group for connecting edges
      std::cout << cur_group.size() << ", ";
      last_group = cur_group;
      cur_group.clear();
   }

{% endhighlight %}

#### cost 计算
{% highlight cpp %}
   double ViewNode::computeCost(const Vector3d &p1, const Vector3d &p2, const double &y1, const double &y2, const Vector3d &v1, const double &yd1, vector<Vector3d> &path)
   {
      // 1. 计算位置变化代价， /最大速度，用于规一化距离成本为时间
      double pos_cost = ViewNode::searchPath(p1, p2, path) / vm_;

      // 2. 考虑速度方向变化的代价
      if (v1.norm() > 1e-3)
      {
         Vector3d dir = (p2 - p1).normalized(); //目标方向
         Vector3d vdir = v1.normalized();       //速度方向
         double diff = acos(vdir.dot(dir));     //计算速度方向和目标方向的夹角
         pos_cost += w_dir_ * diff;             // 乘一个权重 加到位置代价
      }

      // 3. 航向变化的代价
      double diff = fabs(y2 - y1);       // 计算航向角度差的绝对值
      diff = min(diff, 2 * M_PI - diff); // 考虑2派周期， 得到的是最短旋转路径
      double yaw_cost = diff / yd_;      // 用差值 除 最大航向角速度
      return max(pos_cost, yaw_cost);
   }
{% endhighlight %}


### Djikstra

#### 核心思想

**1. 初始化：** 维护一个集合，记录已找到最短路径的节点，以及一个距离数组，记录从起点到每个节点的当前最短距离。起点到自身的距离设为 0，到其他所有节点的距离设为无穷大（**$\infty$**）。

**2. 迭代：** 重复以下步骤，直到所有节点都被访问或目标节点被访问：

* 从**尚未确定最短路径的节点**中，选择一个**当前距离起点最近**的节点 **$u$**。
* 将节点 **$u$** 标记为“已确定最短路径”。
* 松弛操作 (Relaxation)： 遍历 $u$ 的所有邻接点 $v$。如果通过 $u$ 到达 $v$ 的距离更短，则更新 $v$ 的最短距离。
  $$
  \text{dist}[v] = \min(\text{dist}[v], \text{dist}[u] + \text{weight}(u, v))
  $$
* 为了记录路径，通常还需要一个**前驱（`parent`）数组**来记录到达 **$v$** 的最短路径上的前一个节点。

#### 算法原理

##### 初始化

1. 距离数组 **$\text{dist}[]$**，初始化 **$\text{dist}[\text{start}] = 0$**，其余为 **$\infty$**
2. 前驱数组 **$\text{parent}[]$**，用于路径重建, 保存的是上一个节点
3. 优先队列 **$PQ$**，存储 **$\langle \text{距离}, \text{节点ID} \rangle$**，初始将 **$\langle 0, \text{start} \rangle$** 压入

##### 循环

* 从 **$PQ$** 中取出距离最小的节点 **$u$**（及其距离 **$d$**）。
* **剪枝/优化** ：如果 **$d > \text{dist}[u]$**，说明 **$u$** 已经被更短的路径更新过，跳过本次循环。
* **松弛** ：对于 **$u$** 的每个邻居 **$v$**（边权为 **$w$**）：
* 如果 **$\text{dist}[u] + w < \text{dist}[v]$**：
  * 更新 **$\text{dist}[v] = \text{dist}[u] + w$**。
  * 设置 **$\text{parent}[v] = u$**。
  * 将 **$\langle \text{dist}[v], v \rangle$** 压入 **$PQ$**。

#### 复杂度计算

时间复杂度：

| **操作**                        | **执行次数**                  | **单次耗时（优先队列）** | **总耗时**          |
| ------------------------------------- | ----------------------------------- | ------------------------------ | ------------------------- |
| **取出最小元素 (`pq.pop()`)** | **$V$**次（每个节点最多出队一次） | **$O(\log V)$**        | **$O(V \log V)$** |
| **松弛操作 (`pq.push()`)**    | **$E$**次（每条边最多检查一次）   | **$O(\log V)$**        | **$O(E \log V)$** |

空间复杂度：

| **数据结构**              | **空间占用**     | **作用**                                                                                                       |
| ------------------------------- | ---------------------- | -------------------------------------------------------------------------------------------------------------------- |
| **邻接表 (`Graph`)**    | **$O(V + E)$** | 存储图结构（**$V$**个节点列表，共**$E$**条边记录）。                                                       |
| **距离数组 (`dist`)**   | **$O(V)$**     | 存储从起点到所有节点的当前最短距离。                                                                                 |
| **前驱数组 (`parent`)** | **$O(V)$**     | 用于路径重建。                                                                                                       |
| **优先队列 (`pq`)**     | 最坏**$O(E)$**       | 最坏情况下，每条边松弛操作都会导致一个元素入队，虽然许多可能是重复的。实际上，在任何时刻，其大小通常远小于**$E$**. |

#### 优缺点

##### ✅ 优点 (Advantages)

1. **全局最优解** ：能够保证找到从起点到**所有其他可达节点**的 **最短路径** ，结果是绝对准确的。
2. **效率高** ：在边的权重为非负数的情况下，优先队列优化的 Dijkstra 算法 **$O((V+E)\log V)$** 效率非常高，适用于大型稀疏图。
3. **算法简单清晰** ：核心思想是贪心策略和松弛操作，概念相对容易理解和实现。
4. **应用广泛** ：是 GPS 导航、网络路由协议（如 OSPF）等许多实际应用的基础。

##### ❌ 缺点 (Disadvantages)

1. **无法处理负权边** ：这是 Dijkstra 算法最主要的限制。如果图中有 **负权边** ，Dijkstra 算法的贪心策略就会失效，无法保证找到最短路径。

* *替代方案：* 如果存在负权边，必须使用 **Bellman-Ford 算法** (**$O(VE)$**) 或  **SPFA 算法** （在实际应用中通常很快，但最坏情况是 **$O(VE)$**）。

1. **单源计算** ：它只能解决**单源最短路径**问题（从一个起点到所有其他点）。如果需要找到所有节点对之间的最短路径，需要运行 **$V$** 次 Dijkstra，总复杂度变为 **$O(V(V+E)\log V)$**。

* *替代方案：* 所有对最短路径问题通常使用 **Floyd-Warshall 算法** (**$O(V^3)$**)。

1. **计算范围大** ：即使您只需要从 **$A$** 到 **$B$** 的路径，Dijkstra 算法在最坏情况下也可能需要探索图中的大部分区域，因为它本质上是计算从 **$A$** 到**所有**点的最短路径。

* *替代方案：* 带有启发式搜索的  **A* 算法** ，在知道目标位置的情况下，可以更快地收敛到终点。

### A*
#### 算法原理

A* (A-star) 算法是图搜索算法中最著名和最成功的算法之一。它通常用于**寻路**和 **图遍历** ，尤其是在有明确目标的情况下，它比 Dijkstra 算法更高效。

## 核心思想：评估函数 **$f(n)$**

A* 算法通过引入一个**启发式函数（Heuristic Function）**来指导搜索方向，使其优先搜索靠近目标的节点，从而避免像 Dijkstra 那样“盲目”地向各个方向扩展。

A* 算法在选择下一个要探索的节点 **$n$** 时，依据一个**评估函数 **$f(n)$**** 的最小值：

$$
f(n) = g(n) + h(n)
$$

| **组成部分** | **含义**                        | **解释 (与 Dijkstra 区别)**                                                                                                           |
| ------------------ | ------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |
| **$g(n)$** | **实际成本 (Actual Cost)**      | 从**起点**到当前节点**$n$**的 **实际最短路径成本** 。**这部分与 Dijkstra 算法的**$\text{dist}[n]$**完全相同。** |
| **$h(n)$** | **启发式成本 (Heuristic Cost)** | 从当前节点**$n$**到**目标点**的 **估计成本** 。这个估计值必须是 **可接受的 (Admissible)** 。                            |
| **$f(n)$** | **总评估成本 (Total Cost)**     | 从**起点**经过**$n$**到达**目标点**的 **总估计成本** 。算法总是优先选择**$f(n)$**最小的节点。                   |

#### 常见启发式函数

在网格地图（如游戏或机器人路径规划）中，最常用的启发式函数是：

* 曼哈顿距离 (Manhattan Distance)：用于允许四个方向移动的网格图。
  $$
  h(n) = |x_n - x_{\text{目标}}| + |y_n - y_{\text{目标}}|
  $$
* 欧几里得距离 (Euclidean Distance)：用于允许八个方向移动的网格图。
  $$
  h(n) = \sqrt{(x_n - x_{\text{目标}})^2 + (y_n - y_{\text{目标}})^2}
  $$

#### 算法步骤总结

A* 算法的步骤与 Dijkstra 非常相似，主要区别在于优先队列中存储和比较的值：

1. **初始化** ：使用两个列表/集合，`OpenList`（相当于 Dijkstra 的优先队列，存储待访问节点）和 `ClosedList`（存储已访问节点）。
2. **设置** ：

* **$\text{g\_score}[n]$** 存储 **$g(n)$**，初始化起点 **$\text{g\_score}[\text{start}] = 0$**，其他为 **$\infty$**。
* **$\text{f\_score}[n]$** 存储 **$f(n)$**，初始化 **$\text{f\_score}[\text{start}] = h(\text{start})$**，其他为 **$\infty$**。
* 将 **$\langle f(\text{start}), \text{start} \rangle$** 压入优先队列 (`OpenList`)。

3. **循环** ：当 `OpenList` 不为空时：

* 从 `OpenList` 中取出 **$f(n)$** 最小的节点 **$u$**。
* 如果 **$u$** 是目标点，则停止并重建路径。
* 对于 **$u$** 的每个邻居 **$v$**：
  * 计算通过 **$u$** 到达 **$v$** 的新 **$g$** 值：**$\text{new\_g} = \text{g\_score}[u] + \text{weight}(u, v)$**。
  * **松弛** ：如果 **$\text{new\_g} < \text{g\_score}[v]$**：
  * 更新 **$\text{g\_score}[v] = \text{new\_g}$**。
  * 更新 **$\text{f\_score}[v] = \text{g\_score}[v] + h(v)$**。
  * 记录前驱 **$\text{parent}[v] = u$**。
  * 将 **$\langle f(v), v \rangle$** 压入 `OpenList`。

#### 复杂度

##### 时间复杂度

$$
\text{最坏时间复杂度} = O((V + E) \log V)
$$

**然而，A* 的实际性能优势体现在其平均/最佳时间复杂度上：**

* **平均耗时：** 当启发式函数 **$h(n)$** 优秀且具有指导性时，A* 算法只会搜索地图的一小部分（靠近目标点的区域），而不是像 Dijkstra 那样均匀地向外扩展。
  * **搜索节点数 **$V'$**:** 实际探索的节点数 **$V'$** 远小于总节点数 **$V$**。
  * **实际复杂度：** 在许多实际应用中，A* 的表现更接近于 **$O(V' \log V')$**，其中 **$V'$** 是算法实际遍历的节点数。
  * **当 **$h(n)$** 非常准确时（例如 **$h(n)$** 等于实际最短距离）：** A* 的搜索可以非常接近线性时间 **$O(V')$**.

##### 空间复杂度

| **数据结构**             | **空间占用**                   | **作用**                                                                                      |
| ------------------------------ | ------------------------------------ | --------------------------------------------------------------------------------------------------- |
| **节点数组 (`nodes`)** | **$O(V)$**                   | 存储所有节点的状态（**$g\_score, f\_score, \text{parent}, x, y$**）。这是最主要的内存占用。 |
| **优先队列 (`pq`)**    | 最坏**$O(V)$**或**$O(E)$** | 存储待探索的节点。最坏情况下与边的数量**$E$**成正比，但在稀疏网格图中为**$O(V)$**。       |
| **输入地图 (`map`)**   | **$O(V)$**                   | 存储网格障碍物信息。                                                                                |

**总空间复杂度**为：

$$
O(V)
$$

#### 优缺点总结

##### ✅ 优点 (Advantages)

1. **效率极高（定向搜索）** ：这是 A* 相较于 Dijkstra 最大的优势。通过使用启发式函数 **$h(n)$**，A* 能够将搜索重点放在接近目标点的区域，从而避免探索大量无关节点，大大节省了计算时间。
2. **保证最优解（完备性）** ：只要使用的启发式函数 **$h(n)$** 是 **可接受的 (Admissible)** （即永不夸大实际成本），A* 就能保证找到最短路径。
3. **适应性强** ：可以通过调整启发式函数来平衡搜索速度和最优性：

* **提高 **$h(n)$** 精度** ：搜索速度更快，但需确保仍是可接受的。
* **$h(n) = 0$** ：退化为 Dijkstra，保证最优但速度慢。

1. **应用广泛** ：它是游戏寻路、机器人导航、物流规划等许多领域中最常用的算法。

##### ❌ 缺点 (Disadvantages)

1. **内存消耗大** ：A* 必须存储所有已访问节点的信息（在您的代码中是整个 **$R \times C$** 的 `nodes` 数组），以便进行松弛操作和路径重建。对于非常大的地图或图，内存限制可能是一个问题。

* *Dijkstra 也需要存储所有节点的 `dist`，但 A* 对内存的压力通常更大，因为它需要存储更多的状态信息。*

1. **依赖启发式函数** ：A* 的效率和正确性**强烈依赖**于启发式函数的质量：

* **$h(n)$ 不可接受** ：如果启发式函数夸大了实际成本，A* 算法可能无法保证找到最短路径。
* **$h(n)$ 太小** ：如果启发式函数太小（接近 0），A* 的性能会接近 Dijkstra，失去定向搜索的优势。

1. **无法处理负权边** ：与 Dijkstra 算法一样，A* 算法的贪心策略依赖于边的非负权。如果图中有负权边，A* 算法会失效。

### B样条曲线插值优化

### 差速轮动力学模型

## PID+puresuit控制

## 补充

### 四元数转欧拉角，如何防止奇异性？ 如何防止万向锁

# ROS1 / ROS2

