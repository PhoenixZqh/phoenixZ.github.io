---
layout:     post
title:      项目总结
subtitle:   
date:       2024-11-15
author:     phoenixZ
header-img: /img/oip3.jpg
catalog: true
tags:
    - boss
---
# 航迹飞行区域覆盖

## 区域覆盖

根据区域： 圆形、矩形 取最小的X，Y；

**圆形的话：**

1. 先根据GPS2XYZ，  利用圆心和半径得到 Xmin， Xmax， Ymin， Ymax
2. 根据间隔n米一个点的原则，从左下到左上，S形走位，并且要判断点在不在圆形内(勾股定理， 点与圆心点的平方距离)

**多边形的话：**

1. 直接可以得到Xmin, Ymin
2. 根据间隔n米一个点的原则，判断生成多少个点

```cpp
void algo_search::generatePoints()
{

    all_point.clear();

    int x_count = (xMax - xMin) / per_distance + 1;

    int y_count = (yMax - yMin) / per_distance + 1;

    all_point.emplace_back(xMin, yMin, mission_get.missions[0].height);

    double y_start = yMin;

    for (int j = 1; j <= y_count; ++j)
    {

        y_start += per_distance;

        all_point.emplace_back(xMin, y_start, mission_get.missions[0].height);
    }

    double x_start = xMin;

    for (int i = 1; i <= x_count; ++i)

    {

        x_start += per_distance;

        all_point.emplace_back(x_start, y_start, mission_get.missions[0].height);

        for (int j = 1; j <= y_count; ++j)
        {

            if ((i % 2) == 1)

            {

                y_start -= per_distance;
            }

            else
            {

                y_start += per_distance;
            }

            all_point.emplace_back(x_start, y_start, mission_get.missions[0].height);
        }
    }
}
```

## PID

PID 是比例-积分-微分控制

我是这样理解的： 想象有一桶水， 当前水量0.2L, 目标水量1L

**对于比例控制**：

U = Kp * (目标值 - 当前值)， 假设1s加一次水， 一次加0.5L

第一帧：U = 0.5 * 0.8 = 0.4,  diff = 1-0.6 = 0.4
第二帧：U = 0.5 * 0.4 = 0.2,  diff = 1-0.8 = 0.2
第三帧：U = 0.5 * 0.2 = 0.1,  diff = 1-0.9 = 0.1
...

但是如果考虑水缸会漏水的情况，就会有稳态误差的形成， 也就是稳定在0.8L不往上增加了

**这时需要引入积分控制**

U = Kp × diff + Ki × 累积的diff

增加每次的输入，防止稳态误差

**对于微分控制**

U = Kp × diff + Ki × 累积的diff + Kp*(diff / dt)

微分控制主要是防止震荡

# 目标跟随与防丢失策略

## yolo部署

## 卡尔曼滤波 

## 单目测距

## EKF

## 云台控制


## 防丢失策略

1. 跟随过程中往前走一段距离
2. 以跟随距离为半径，丢失前的目标点为圆形进行环绕搜索

```cpp
void Follow::geratePoints()
{
    circle_angles_.clear();
    float start_angle = atan2(cur_pos_.y - target_pos_.y, cur_pos_.x - target_pos_.x) * (180.0f / M_PI);
    for (int i = 0; i < 360 / std::abs(circle_spd_); ++i) {
        circle_angles_.emplace_back((start_angle + i * circle_spd_) * (M_PI / 180.0f));
    }
    std::reverse(circle_angles_.begin(), circle_angles_.end());
}
```


# DJI PSDK


# 多无人车协同搜索

## 边界与视点生成

## 区域分配算法

## 路径规划

### 差速轮动力学模型

### Djikstra

### A*

### B样条曲线插值优化

## PID+puresuit控制
