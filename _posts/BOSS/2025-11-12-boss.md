---
layout:     post
title:      项目总结
subtitle:   
date:       2024-11-15
author:     phoenixZ
header-img: /img/oip3.jpg
catalog: true
tags:
    - boss
---
# 航迹飞行区域覆盖

## 区域覆盖

根据区域： 圆形、矩形 取最小的X，Y；

**圆形的话：**

1. 先根据GPS2XYZ，  利用圆心和半径得到 Xmin， Xmax， Ymin， Ymax
2. 根据间隔n米一个点的原则，从左下到左上，S形走位，并且要判断点在不在圆形内(勾股定理， 点与圆心点的平方距离)

**多边形的话：**

1. 直接可以得到Xmin, Ymin
2. 根据间隔n米一个点的原则，判断生成多少个点

```cpp
void algo_search::generatePoints()
{

    all_point.clear();

    int x_count = (xMax - xMin) / per_distance + 1;

    int y_count = (yMax - yMin) / per_distance + 1;

    all_point.emplace_back(xMin, yMin, mission_get.missions[0].height);

    double y_start = yMin;

    for (int j = 1; j <= y_count; ++j)
    {

        y_start += per_distance;

        all_point.emplace_back(xMin, y_start, mission_get.missions[0].height);
    }

    double x_start = xMin;

    for (int i = 1; i <= x_count; ++i)

    {

        x_start += per_distance;

        all_point.emplace_back(x_start, y_start, mission_get.missions[0].height);

        for (int j = 1; j <= y_count; ++j)
        {

            if ((i % 2) == 1)

            {

                y_start -= per_distance;
            }

            else
            {

                y_start += per_distance;
            }

            all_point.emplace_back(x_start, y_start, mission_get.missions[0].height);
        }
    }
}
```

## PID

PID 是比例-积分-微分控制

我是这样理解的： 想象有一桶水， 当前水量0.2L, 目标水量1L

**对于比例控制**：

U = Kp * (目标值 - 当前值)， 假设1s加一次水， 一次加0.5L

第一帧：U = 0.5 * 0.8 = 0.4,  diff = 1-0.6 = 0.4
第二帧：U = 0.5 * 0.4 = 0.2,  diff = 1-0.8 = 0.2
第三帧：U = 0.5 * 0.2 = 0.1,  diff = 1-0.9 = 0.1
...

但是如果考虑水缸会漏水的情况，就会有稳态误差的形成， 也就是稳定在0.8L不往上增加了

**这时需要引入积分控制**

U = Kp × diff + Ki × 累积的diff

增加每次的输入，防止稳态误差

**对于微分控制**

U = Kp × diff + Ki × 累积的diff + Kp*(diff / dt)

微分控制主要是防止震荡

# 目标跟随与防丢失策略

## yolo部署

## 卡尔曼滤波

卡尔曼滤波器是一种用于**线性**系统状态估计的递归算法。它通过融合带有噪声的测量值和一个包含系统动态的预测模型，来产生对系统状态的最优估计。这里的“最优”是指在最小均方误差 (Minimum Mean Square Error, MMSE) 意义下。

### 核心假设

1. **系统是线性的。**
2. **过程噪声和测量噪声是零均值、高斯分布（正态分布）的白噪声。**

### 1. 系统模型 (System Model)

一个离散时间线性系统可以表示为：

* 状态转移方程 (Prediction):
  $$
  x_k = F_{k-1} x_{k-1} + B_{k-1} u_{k-1} + w_{k-1}
  $$
* 测量方程 (Update):
  $$
  z_k = H_k x_k + v_k
  $$

| **符号**        | **描述**                                                                           |
| --------------------- | ---------------------------------------------------------------------------------------- |
| **$x_k$**     | **$k$**时刻的**系统状态向量**                                              |
| **$x_{k-1}$** | **$k-1$**时刻的系统状态向量                                                            |
| **$F_{k-1}$** | **状态转移矩阵**(或 **系统矩阵** )，将**$x_{k-1}$**映射到**$x_k$** |
| **$u_{k-1}$** | **$k-1$**时刻的**控制输入向量**                                            |
| **$B_{k-1}$** | **控制输入矩阵**(或 **控制矩阵** )，将**$u_{k-1}$**映射到**$x_k$** |
| **$w_{k-1}$** | **过程噪声向量** ，假设**$w_{k-1} \sim N(0, Q_{k-1})$**                          |
| **$Q_{k-1}$** | **过程噪声协方差矩阵**                                                             |
| **$z_k$**     | **$k$**时刻的**测量向量**                                                  |
| **$H_k$**     | **观测矩阵**(或 **测量矩阵** )，将**$x_k$**映射到**$z_k$**         |
| **$v_k$**     | **测量噪声向量** ，假设**$v_k \sim N(0, R_k)$**                                  |
| **$R_k$**     | **测量噪声协方差矩阵**                                                             |

### 2. 核心公式 (Recursive Steps)

KF 包含两个阶段：**预测 (Prediction)** 和  **更新 (Update)** 。

#### A. 预测阶段 (Time Update)

利用系统的动态模型来预测下一时刻的状态和误差协方差。

1. 先验状态估计 (Predicted State Estimate):
   $$
   \hat{x}_k^- = F_{k-1} \hat{x}_{k-1}^+ + B_{k-1} u_{k-1}
   $$
2. 先验误差协方差 (Predicted Covariance Estimate):
   $$
   P_k^- = F_{k-1} P_{k-1}^+ F_{k-1}^T + Q_{k-1}
   $$


| **符号**                | **描述**                                                              |
| ----------------------------- | --------------------------------------------------------------------------- |
| **$\hat{x}_k^-$**     | **$k$**时刻的**先验**状态估计 (未结合**$z_k$**测量值)       |
| **$\hat{x}_{k-1}^+$** | **$k-1$**时刻的**后验**状态估计 (已结合**$z_{k-1}$**测量值) |
| **$P_k^-$**           | **$k$**时刻的**先验**误差协方差矩阵                           |
| **$P_{k-1}^+$**       | **$k-1$**时刻的**后验**误差协方差矩阵                         |

#### B. 更新阶段 (Measurement Update)

利用当前时刻的测量值 **$z_k$** 来修正先验估计，得到更准确的后验估计。

1. 卡尔曼增益 (Kalman Gain):
   $$
   K_k = P_k^- H_k^T (H_k P_k^- H_k^T + R_k)^{-1}
   $$
2. 后验状态估计 (Updated State Estimate):
   $$
   \hat{x}_k^+ = \hat{x}_k^- + K_k (z_k - H_k \hat{x}_k^-)
   $$
3. 后验误差协方差 (Updated Covariance Estimate):
   $$
   P_k^+ = (I - K_k H_k) P_k^-
   $$


| **符号**            | **描述**                                                        |
| ------------------------- | --------------------------------------------------------------------- |
| **$K_k$**         | **卡尔曼增益矩阵** ，用于平衡预测和测量之间的权重               |
| **$\hat{x}_k^+$** | **$k$**时刻的**后验**状态估计 (已结合**$z_k$**测量值) |
| **$P_k^+$**       | **$k$**时刻的**后验**误差协方差矩阵                     |
| **$I$**           | 适当维度的**单位矩阵**                                          |

## EKF

当系统模型（状态转移方程或测量方程，或两者）是**非线性**时，标准的 KF 就不能直接使用了。EKF 是 KF 针对非线性系统的一种近似解决方案。

### 核心思想

EKF 的核心思想是：在每次状态预测和测量更新时，用**一阶泰勒级数展开**来近似非线性系统，从而将非线性问题 **局部线性化** ，然后应用标准的 KF 公式。

### 1. 系统模型 (Nonlinear System Model)

非线性离散时间系统可以表示为：

* 状态转移方程 (Prediction):
  $$
  x_k = f(x_{k-1}, u_{k-1}) + w_{k-1}
  $$
* 测量方程 (Update):
  $$
  z_k = h(x_k) + v_k
  $$


| **符号**         | **描述**               |
| ---------------------- | ---------------------------- |
| **$f(\cdot)$** | **非线性**状态转移函数 |
| **$h(\cdot)$** | **非线性**测量函数     |

### 2. 核心公式 (Recursive Steps for EKF)

EKF 最大的区别在于，它用**雅可比矩阵** (Jacobian Matrix) 来代替 KF 中的 **$F$** 和 **$H$** 矩阵。

#### A. 预测阶段 (Time Update)

1. 先验状态估计:
   $$
   \hat{x}_k^- = f(\hat{x}_{k-1}^+, u_{k-1})
   $$

   (注意：这里直接将后验状态估计 $\hat{x}_{k-1}^+$ 代入非线性函数 $f$。)
2. 线性化：计算状态转移雅可比矩阵 $F_{k-1}$，这是 $f(\cdot)$ 关于状态 $x$ 的偏导数。
   $$
   F_{k-1} = \left.\frac{\partial f}{\partial x}\right|_{\hat{x}_{k-1}^+, u_{k-1}}
   $$
3. 先验误差协方差:
   $$
   P_k^- = F_{k-1} P_{k-1}^+ F_{k-1}^T + Q_{k-1}
   $$

   (公式结构与 KF 相同，但 $F_{k-1}$ 是雅可比矩阵。)

#### B. 更新阶段 (Measurement Update)

1. 线性化：计算观测雅可比矩阵 $H_k$，这是 $h(\cdot)$ 关于状态 $x$ 的偏导数。

   $$
   H_k = \left.\frac{\partial h}{\partial x}\right|_{\hat{x}_k^-}
   $$

   (在预测状态 $\hat{x}_k^-$ 处进行线性化。)
2. 卡尔曼增益:

   $$
   K_k = P_k^- H_k^T (H_k P_k^- H_k^T + R_k)^{-1}
   $$

   (公式结构与 KF 相同，但 $H_k$ 是雅可比矩阵。)
3. 后验状态估计:

   $$
   \hat{x}_k^+ = \hat{x}_k^- + K_k (z_k - h(\hat{x}_k^-))
   $$

   (注意：这里的测量残差是用实际测量 $z_k$ 减去通过非线性函数 $h(\cdot)$ 得到的预测测量。)
4. 后验误差协方差:

   $$
   P_k^+ = (I - K_k H_k) P_k^-
   $$


## 单目测距

## 云台控制

## 防丢失策略

1. 跟随过程中往前走一段距离
2. 以跟随距离为半径，丢失前的目标点为圆形进行环绕搜索

```cpp
void Follow::geratePoints()
{
    circle_angles_.clear();
    float start_angle = atan2(cur_pos_.y - target_pos_.y, cur_pos_.x - target_pos_.x) * (180.0f / M_PI);
    for (int i = 0; i < 360 / std::abs(circle_spd_); ++i) {
        circle_angles_.emplace_back((start_angle + i * circle_spd_) * (M_PI / 180.0f));
    }
    std::reverse(circle_angles_.begin(), circle_angles_.end());
}
```

# DJI PSDK

# 多无人车协同搜索

## 边界与视点生成

## 区域分配算法

## 路径规划

### 差速轮动力学模型

### Djikstra

### A*

### B样条曲线插值优化

## PID+puresuit控制
